// Package metronome provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.12.4 DO NOT EDIT.
package metronome

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
	"github.com/getkin/kin-openapi/openapi3"
)

const (
	BearerAuthScopes = "bearerAuth.Scopes"
)

// Defines values for AddPlanToCustomerPayloadPriceAdjustmentsAdjustmentType.
const (
	AddPlanToCustomerPayloadPriceAdjustmentsAdjustmentTypeFixed      AddPlanToCustomerPayloadPriceAdjustmentsAdjustmentType = "fixed"
	AddPlanToCustomerPayloadPriceAdjustmentsAdjustmentTypeOverride   AddPlanToCustomerPayloadPriceAdjustmentsAdjustmentType = "override"
	AddPlanToCustomerPayloadPriceAdjustmentsAdjustmentTypePercentage AddPlanToCustomerPayloadPriceAdjustmentsAdjustmentType = "percentage"
	AddPlanToCustomerPayloadPriceAdjustmentsAdjustmentTypeQuantity   AddPlanToCustomerPayloadPriceAdjustmentsAdjustmentType = "quantity"
)

// Defines values for AlertStatus.
const (
	AlertStatusArchived AlertStatus = "archived"
	AlertStatusDisabled AlertStatus = "disabled"
	AlertStatusEnabled  AlertStatus = "enabled"
)

// Defines values for AlertType.
const (
	AlertTypeLowCreditBalanceReached             AlertType = "low_credit_balance_reached"
	AlertTypeLowRemainingCreditPercentageReached AlertType = "low_remaining_credit_percentage_reached"
	AlertTypeLowRemainingDaysInPlanReached       AlertType = "low_remaining_days_in_plan_reached"
	AlertTypeSpendThresholdReached               AlertType = "spend_threshold_reached"
	AlertTypeUsageThresholdReached               AlertType = "usage_threshold_reached"
)

// Defines values for AwsRegion.
const (
	AfSouth1     AwsRegion = "af-south-1"
	ApEast1      AwsRegion = "ap-east-1"
	ApNortheast1 AwsRegion = "ap-northeast-1"
	ApNortheast2 AwsRegion = "ap-northeast-2"
	ApNortheast3 AwsRegion = "ap-northeast-3"
	ApSouth1     AwsRegion = "ap-south-1"
	ApSoutheast1 AwsRegion = "ap-southeast-1"
	ApSoutheast2 AwsRegion = "ap-southeast-2"
	CaCentral1   AwsRegion = "ca-central-1"
	CnNorth1     AwsRegion = "cn-north-1"
	CnNorthwest1 AwsRegion = "cn-northwest-1"
	EuCentral1   AwsRegion = "eu-central-1"
	EuNorth1     AwsRegion = "eu-north-1"
	EuSouth1     AwsRegion = "eu-south-1"
	EuWest1      AwsRegion = "eu-west-1"
	EuWest2      AwsRegion = "eu-west-2"
	EuWest3      AwsRegion = "eu-west-3"
	MeSouth1     AwsRegion = "me-south-1"
	SaEast1      AwsRegion = "sa-east-1"
	UsEast1      AwsRegion = "us-east-1"
	UsEast2      AwsRegion = "us-east-2"
	UsGovEast1   AwsRegion = "us-gov-east-1"
	UsGovWest1   AwsRegion = "us-gov-west-1"
	UsWest1      AwsRegion = "us-west-1"
	UsWest2      AwsRegion = "us-west-2"
)

// Defines values for BillingProviderType.
const (
	AwsMarketplace BillingProviderType = "aws_marketplace"
	Stripe         BillingProviderType = "stripe"
)

// Defines values for ChargeType.
const (
	ChargeTypeComposite ChargeType = "composite"
	ChargeTypeFixed     ChargeType = "fixed"
	ChargeTypeMinimum   ChargeType = "minimum"
	ChargeTypeUsage     ChargeType = "usage"
)

// Defines values for CreateCustomerAlertPayloadAlertType.
const (
	CreateCustomerAlertPayloadAlertTypeLowCreditBalanceReached             CreateCustomerAlertPayloadAlertType = "low_credit_balance_reached"
	CreateCustomerAlertPayloadAlertTypeLowRemainingCreditPercentageReached CreateCustomerAlertPayloadAlertType = "low_remaining_credit_percentage_reached"
	CreateCustomerAlertPayloadAlertTypeLowRemainingDaysInPlanReached       CreateCustomerAlertPayloadAlertType = "low_remaining_days_in_plan_reached"
	CreateCustomerAlertPayloadAlertTypeSpendThresholdReached               CreateCustomerAlertPayloadAlertType = "spend_threshold_reached"
	CreateCustomerAlertPayloadAlertTypeUsageThresholdReached               CreateCustomerAlertPayloadAlertType = "usage_threshold_reached"
)

// Defines values for CustomerAlertCustomerStatus.
const (
	Evaluating CustomerAlertCustomerStatus = "evaluating"
	InAlarm    CustomerAlertCustomerStatus = "in_alarm"
	Ok         CustomerAlertCustomerStatus = "ok"
)

// Defines values for EmbeddableDashboardPayloadColorOverridesName.
const (
	GrayDark       EmbeddableDashboardPayloadColorOverridesName = "Gray_dark"
	GrayExtralight EmbeddableDashboardPayloadColorOverridesName = "Gray_extralight"
	GrayLight      EmbeddableDashboardPayloadColorOverridesName = "Gray_light"
	GrayMedium     EmbeddableDashboardPayloadColorOverridesName = "Gray_medium"
	PrimaryLight   EmbeddableDashboardPayloadColorOverridesName = "Primary_light"
	PrimaryMedium  EmbeddableDashboardPayloadColorOverridesName = "Primary_medium"
	White          EmbeddableDashboardPayloadColorOverridesName = "White"
)

// Defines values for EmbeddableDashboardPayloadDashboard.
const (
	Invoices EmbeddableDashboardPayloadDashboard = "invoices"
	Usage    EmbeddableDashboardPayloadDashboard = "usage"
)

// Defines values for ExternalInvoiceExternalStatus.
const (
	DELETED       ExternalInvoiceExternalStatus = "DELETED"
	DRAFT         ExternalInvoiceExternalStatus = "DRAFT"
	FINALIZED     ExternalInvoiceExternalStatus = "FINALIZED"
	PAID          ExternalInvoiceExternalStatus = "PAID"
	PAYMENTFAILED ExternalInvoiceExternalStatus = "PAYMENT_FAILED"
	UNCOLLECTIBLE ExternalInvoiceExternalStatus = "UNCOLLECTIBLE"
	VOID          ExternalInvoiceExternalStatus = "VOID"
)

// Defines values for ListCustomerAlertsPayloadAlertStatuses.
const (
	ListCustomerAlertsPayloadAlertStatusesARCHIVED  ListCustomerAlertsPayloadAlertStatuses = "ARCHIVED"
	ListCustomerAlertsPayloadAlertStatusesArchived  ListCustomerAlertsPayloadAlertStatuses = "archived"
	ListCustomerAlertsPayloadAlertStatusesArchived1 ListCustomerAlertsPayloadAlertStatuses = "Archived"
	ListCustomerAlertsPayloadAlertStatusesDISABLED  ListCustomerAlertsPayloadAlertStatuses = "DISABLED"
	ListCustomerAlertsPayloadAlertStatusesDisabled  ListCustomerAlertsPayloadAlertStatuses = "disabled"
	ListCustomerAlertsPayloadAlertStatusesDisabled1 ListCustomerAlertsPayloadAlertStatuses = "Disabled"
	ListCustomerAlertsPayloadAlertStatusesENABLED   ListCustomerAlertsPayloadAlertStatuses = "ENABLED"
	ListCustomerAlertsPayloadAlertStatusesEnabled   ListCustomerAlertsPayloadAlertStatuses = "enabled"
	ListCustomerAlertsPayloadAlertStatusesEnabled1  ListCustomerAlertsPayloadAlertStatuses = "Enabled"
)

// Defines values for ManagedEntity.
const (
	ManagedEntityCharge      ManagedEntity = "charge"
	ManagedEntityCreditGrant ManagedEntity = "credit_grant"
	ManagedEntityCustomer    ManagedEntity = "customer"
	ManagedEntityProduct     ManagedEntity = "product"
)

// Defines values for PagedUsageQueryPayloadWindowSize.
const (
	PagedUsageQueryPayloadWindowSizeDAY   PagedUsageQueryPayloadWindowSize = "DAY"
	PagedUsageQueryPayloadWindowSizeDay   PagedUsageQueryPayloadWindowSize = "day"
	PagedUsageQueryPayloadWindowSizeDay1  PagedUsageQueryPayloadWindowSize = "Day"
	PagedUsageQueryPayloadWindowSizeHOUR  PagedUsageQueryPayloadWindowSize = "HOUR"
	PagedUsageQueryPayloadWindowSizeHour  PagedUsageQueryPayloadWindowSize = "hour"
	PagedUsageQueryPayloadWindowSizeHour1 PagedUsageQueryPayloadWindowSize = "Hour"
	PagedUsageQueryPayloadWindowSizeNONE  PagedUsageQueryPayloadWindowSize = "NONE"
	PagedUsageQueryPayloadWindowSizeNone  PagedUsageQueryPayloadWindowSize = "none"
	PagedUsageQueryPayloadWindowSizeNone1 PagedUsageQueryPayloadWindowSize = "None"
)

// Defines values for PlanChargeUnitConversionRoundingBehavior.
const (
	Ceiling PlanChargeUnitConversionRoundingBehavior = "ceiling"
	Floor   PlanChargeUnitConversionRoundingBehavior = "floor"
)

// Defines values for PriceAdjustmentPricesAdjustmentType.
const (
	Fixed      PriceAdjustmentPricesAdjustmentType = "fixed"
	Override   PriceAdjustmentPricesAdjustmentType = "override"
	Percentage PriceAdjustmentPricesAdjustmentType = "percentage"
	Quantity   PriceAdjustmentPricesAdjustmentType = "quantity"
)

// Defines values for StripeCollectionMethod.
const (
	ChargeAutomatically StripeCollectionMethod = "charge_automatically"
	SendInvoice         StripeCollectionMethod = "send_invoice"
)

// Defines values for UsageBatchQueryPayloadWindowSize.
const (
	UsageBatchQueryPayloadWindowSizeDAY   UsageBatchQueryPayloadWindowSize = "DAY"
	UsageBatchQueryPayloadWindowSizeDay   UsageBatchQueryPayloadWindowSize = "day"
	UsageBatchQueryPayloadWindowSizeDay1  UsageBatchQueryPayloadWindowSize = "Day"
	UsageBatchQueryPayloadWindowSizeHOUR  UsageBatchQueryPayloadWindowSize = "HOUR"
	UsageBatchQueryPayloadWindowSizeHour  UsageBatchQueryPayloadWindowSize = "hour"
	UsageBatchQueryPayloadWindowSizeHour1 UsageBatchQueryPayloadWindowSize = "Hour"
	UsageBatchQueryPayloadWindowSizeNONE  UsageBatchQueryPayloadWindowSize = "NONE"
	UsageBatchQueryPayloadWindowSizeNone  UsageBatchQueryPayloadWindowSize = "none"
	UsageBatchQueryPayloadWindowSizeNone1 UsageBatchQueryPayloadWindowSize = "None"
)

// AddPlanToCustomerPayload defines model for AddPlanToCustomerPayload.
type AddPlanToCustomerPayload struct {
	// EndingBefore RFC 3339 timestamp for when the plan ends (exclusive) for this customer. Must be at 0:00 UTC (midnight).
	EndingBefore *time.Time `json:"ending_before,omitempty"`

	// NetPaymentTermsDays Number of days after issuance of invoice after which the invoice is due (e.g. Net 30).
	NetPaymentTermsDays *float32           `json:"net_payment_terms_days,omitempty"`
	PlanId              openapi_types.UUID `json:"plan_id"`

	// PriceAdjustments A list of price adjustments can be applied on top of the pricing in the plans. See the [price adjustments documentation](https://docs.metronome.com/pricing/managing-plans/#price-adjustments) for details.
	PriceAdjustments *[]struct {
		AdjustmentType AddPlanToCustomerPayloadPriceAdjustmentsAdjustmentType `json:"adjustment_type"`
		ChargeId       openapi_types.UUID                                     `json:"charge_id"`

		// Quantity the overridden quantity for a fixed charge
		Quantity *float32 `json:"quantity,omitempty"`

		// StartPeriod Used in price ramps.  Indicates how many billing periods pass before the charge applies.
		StartPeriod float32 `json:"start_period"`

		// Tier Used in pricing tiers.  Indicates at what metric value the price applies.
		Tier *float32 `json:"tier,omitempty"`

		// Value The amount of change to a price. Percentage and fixed adjustments can be positive or negative. Percentage-based adjustments should be decimals, e.g. -0.05 for a 5% discount.
		Value *float32 `json:"value,omitempty"`
	} `json:"price_adjustments,omitempty"`

	// StartingOn RFC 3339 timestamp for when the plan becomes active for this customer. Must be at 0:00 UTC (midnight).
	StartingOn time.Time `json:"starting_on"`
}

// AddPlanToCustomerPayloadPriceAdjustmentsAdjustmentType defines model for AddPlanToCustomerPayload.PriceAdjustments.AdjustmentType.
type AddPlanToCustomerPayloadPriceAdjustmentsAdjustmentType string

// Alert defines model for Alert.
type Alert struct {
	CreditType CreditType `json:"credit_type"`

	// Id the Metronome ID of the alert
	Id string `json:"id"`

	// Name Name of the alert
	Name string `json:"name"`

	// Status Status of the alert
	Status AlertStatus `json:"status"`

	// Threshold Threshold value of the alert policy
	Threshold float32 `json:"threshold"`

	// Type Type of the alert
	Type AlertType `json:"type"`

	// UpdatedAt Timestamp for when the alert was last updated
	UpdatedAt time.Time `json:"updated_at"`
}

// AlertStatus Status of the alert
type AlertStatus string

// AlertType Type of the alert
type AlertType string

// AwsExpirationDate Contract expiration date for the customer. The expected format is RFC 3339 and can be retrieved from AWS's GetEntitlements API. (See https://docs.aws.amazon.com/marketplaceentitlement/latest/APIReference/API_GetEntitlements.html.)
type AwsExpirationDate = time.Time

// AwsRegion defines model for AwsRegion.
type AwsRegion string

// BillableMetric defines model for BillableMetric.
type BillableMetric struct {
	GroupBy *[]string          `json:"group_by,omitempty"`
	Id      openapi_types.UUID `json:"id"`
	Name    string             `json:"name"`
}

// BillingProviderType defines model for BillingProviderType.
type BillingProviderType string

// ChargeType defines model for ChargeType.
type ChargeType string

// Costs defines model for Costs.
type Costs struct {
	CreditTypes    CostsPerCreditType `json:"credit_types"`
	EndTimestamp   time.Time          `json:"end_timestamp"`
	StartTimestamp time.Time          `json:"start_timestamp"`
}

// CostsPerCreditType defines model for CostsPerCreditType.
type CostsPerCreditType map[string]struct {
	Cost              *float32             `json:"cost,omitempty"`
	LineItemBreakdown *[]LineItemBreakdown `json:"line_item_breakdown,omitempty"`
	Name              *string              `json:"name,omitempty"`
}

// CreateCreditGrantPayload defines model for CreateCreditGrantPayload.
type CreateCreditGrantPayload struct {
	// CustomerId the Metronome ID of the customer
	CustomerId openapi_types.UUID `json:"customer_id"`

	// EffectiveAt The credit grant will only apply to billing periods that end at or after this timestamp.
	EffectiveAt *time.Time `json:"effective_at,omitempty"`

	// ExpiresAt The credit grant will only apply to billing periods that end before this timestamp.
	ExpiresAt time.Time `json:"expires_at"`

	// GrantAmount the amount of credits granted
	GrantAmount struct {
		Amount       float32            `json:"amount"`
		CreditTypeId openapi_types.UUID `json:"credit_type_id"`
	} `json:"grant_amount"`

	// InvoiceDate The date to issue an invoice for the paid_amount.
	InvoiceDate *time.Time `json:"invoice_date,omitempty"`

	// Name the name of the credit grant as it will appear on invoices
	Name string `json:"name"`

	// PaidAmount the amount paid for this credit grant
	PaidAmount struct {
		Amount       float32            `json:"amount"`
		CreditTypeId openapi_types.UUID `json:"credit_type_id"`
	} `json:"paid_amount"`
	Priority float32 `json:"priority"`

	// ProductIds The product(s) which these credits will be applied to. (If unspecified, the credits will be applied to charges for all products.). The array ordering specified here will be used to determine the order in which credits will be applied to invoice line items
	ProductIds *[]openapi_types.UUID `json:"product_ids,omitempty"`
	Reason     *string               `json:"reason,omitempty"`
}

// CreateCustomerAlertPayload defines model for CreateCustomerAlertPayload.
type CreateCustomerAlertPayload struct {
	// AlertType Type of the alert
	AlertType CreateCustomerAlertPayloadAlertType `json:"alert_type"`

	// BillableMetricId For alerts of type `usage_threshold_reached`, specifies which billable metric to track the usage for.
	BillableMetricId *openapi_types.UUID `json:"billable_metric_id,omitempty"`
	CreditTypeId     *openapi_types.UUID `json:"credit_type_id,omitempty"`

	// CustomerId If provided, will create this alert for this specific customer. To create an alert for all customers, do not specify `customer_id` or `plan_id`.
	CustomerId *openapi_types.UUID `json:"customer_id,omitempty"`

	// Name Name of the alert
	Name string `json:"name"`

	// PlanId If provided, will create this alert for this specific plan. To create an alert for all customers, do not specify `customer_id` or `plan_id`.
	PlanId *openapi_types.UUID `json:"plan_id,omitempty"`

	// Threshold Threshold value of the alert policy
	Threshold float32 `json:"threshold"`
}

// CreateCustomerAlertPayloadAlertType Type of the alert
type CreateCustomerAlertPayloadAlertType string

// CreateCustomerPayload defines model for CreateCustomerPayload.
type CreateCustomerPayload struct {
	BillingConfig *struct {
		AwsProductCode            *string                 `json:"aws_product_code,omitempty"`
		AwsRegion                 *AwsRegion              `json:"aws_region,omitempty"`
		BillingProviderCustomerId string                  `json:"billing_provider_customer_id"`
		BillingProviderType       BillingProviderType     `json:"billing_provider_type"`
		StripeCollectionMethod    *StripeCollectionMethod `json:"stripe_collection_method,omitempty"`
	} `json:"billing_config,omitempty"`

	// ExternalId (deprecated, use ingest_aliases instead) the first ID (Metronome ID or ingest alias) that can be used in usage events
	ExternalId *string `json:"external_id,omitempty"`

	// IngestAliases Aliases that can be used to refer to this customer in usage events
	IngestAliases *[]string `json:"ingest_aliases,omitempty"`
	Name          string    `json:"name"`
}

// CreditGrant defines model for CreditGrant.
type CreditGrant struct {
	// Balance The effective balance of the grant as of the end of the customer's current billing period. Expiration deductions will be included only if the grant expires before the end of the current billing period.
	Balance struct {
		// EffectiveAt The end_date of the customer's current billing period.
		EffectiveAt time.Time `json:"effective_at"`

		// ExcludingPending The grant's current balance including all posted deductions. If the grant has expired, this amount will be 0.
		ExcludingPending float32 `json:"excluding_pending"`

		// IncludingPending The grant's current balance including all posted and pending deductions. If the grant expires before the end of the customer's current billing period, this amount will be 0.
		IncludingPending float32 `json:"including_pending"`
	} `json:"balance"`
	CustomFields CustomField `json:"custom_fields"`

	// CustomerId the Metronome ID of the customer
	CustomerId  openapi_types.UUID  `json:"customer_id"`
	Deductions  []CreditLedgerEntry `json:"deductions"`
	EffectiveAt time.Time           `json:"effective_at"`
	ExpiresAt   time.Time           `json:"expires_at"`

	// GrantAmount the amount of credits initially granted
	GrantAmount struct {
		Amount     float32    `json:"amount"`
		CreditType CreditType `json:"credit_type"`
	} `json:"grant_amount"`

	// Id the Metronome ID of the credit grant
	Id openapi_types.UUID `json:"id"`

	// InvoiceId the Metronome ID of the invoice with the purchase charge for this credit grant, if applicable
	InvoiceId *openapi_types.UUID `json:"invoice_id"`
	Name      string              `json:"name"`

	// PaidAmount the amount paid for this credit grant
	PaidAmount struct {
		Amount     float32    `json:"amount"`
		CreditType CreditType `json:"credit_type"`
	} `json:"paid_amount"`
	PendingDeductions []CreditLedgerEntry `json:"pending_deductions"`
	Priority          float32             `json:"priority"`

	// Products The products which these credits will be applied to. (If unspecified, the credits will be applied to charges for all products.)
	Products *[]struct {
		Id   string `json:"id"`
		Name string `json:"name"`
	} `json:"products,omitempty"`
	Reason *string `json:"reason"`
}

// CreditLedgerEntriesQueryPayload defines model for CreditLedgerEntriesQueryPayload.
type CreditLedgerEntriesQueryPayload struct {
	// CreditTypeIds A list of Metronome credit type IDs to fetch ledger entries for. If absent, ledger entries for all credit types will be returned.
	CreditTypeIds *[]openapi_types.UUID `json:"credit_type_ids,omitempty"`

	// CustomerIds A list of Metronome customer IDs to fetch ledger entries for. If absent, ledger entries for all customers will be returned.
	CustomerIds *[]openapi_types.UUID `json:"customer_ids,omitempty"`

	// EndingBefore If supplied, ledger entries will only be returned with an effective_at before this time. This timestamp must not be in the future. If no timestamp is supplied, all entries up to the start of the customer's next billing period will be returned.
	EndingBefore *time.Time `json:"ending_before,omitempty"`

	// StartingOn If supplied, only ledger entries effective at or after this time will be returned.
	StartingOn *time.Time `json:"starting_on,omitempty"`
}

// CreditLedgerEntry defines model for CreditLedgerEntry.
type CreditLedgerEntry struct {
	// Amount an amount representing the change to the customer's credit balance
	Amount    float32 `json:"amount"`
	CreatedBy string  `json:"created_by"`

	// CreditGrantId the credit grant this entry is related to
	CreditGrantId openapi_types.UUID `json:"credit_grant_id"`
	EffectiveAt   time.Time          `json:"effective_at"`

	// InvoiceId if this entry is a deduction, the Metronome ID of the invoice where the credit deduction was consumed; if this entry is a grant, the Metronome ID of the invoice where the grant's paid_amount was charged
	InvoiceId *openapi_types.UUID `json:"invoice_id"`
	Reason    string              `json:"reason"`

	// RunningBalance the running balance for this credit type at the time of the ledger entry, including all preceding charges
	RunningBalance float32 `json:"running_balance"`
}

// CreditType defines model for CreditType.
type CreditType struct {
	Id   openapi_types.UUID `json:"id"`
	Name string             `json:"name"`
}

// CreditTypeLedger defines model for CreditTypeLedger.
type CreditTypeLedger struct {
	CreditType CreditType `json:"credit_type"`

	// EndingBalance the effective balances at the end of the specified time window
	EndingBalance struct {
		// EffectiveAt the ending_before request parameter (if supplied) or the current billing period's end date
		EffectiveAt time.Time `json:"effective_at"`

		// ExcludingPending the ending balance, including the balance of all grants that have not expired before the effective_at date and deductions that happened before the effective_at date
		ExcludingPending float32 `json:"excluding_pending"`

		// IncludingPending the excluding_pending balance plus any pending invoice deductions and expirations that will happen by the effective_at date
		IncludingPending float32 `json:"including_pending"`
	} `json:"ending_balance"`
	Entries         []CreditLedgerEntry `json:"entries"`
	PendingEntries  []CreditLedgerEntry `json:"pending_entries"`
	StartingBalance struct {
		// EffectiveAt the starting_on request parameter (if supplied) or the first credit grant's effective_at date
		EffectiveAt time.Time `json:"effective_at"`

		// ExcludingPending the starting balance, including all posted grants, deductions, and expirations that happened at or before the effective_at timestamp
		ExcludingPending float32 `json:"excluding_pending"`

		// IncludingPending the excluding_pending balance plus any pending activity that has not been posted at the time of the query
		IncludingPending float32 `json:"including_pending"`
	} `json:"starting_balance"`
}

// CustomField defines model for CustomField.
type CustomField map[string]string

// Customer defines model for Customer.
type Customer struct {
	// ExternalId (deprecated, use ingest_aliases instead) the first ID (Metronome or ingest alias) that can be used in usage events
	ExternalId string `json:"external_id"`

	// Id the Metronome ID of the customer
	Id openapi_types.UUID `json:"id"`

	// IngestAliases aliases for this customer that can be used instead of the Metronome customer ID in usage events
	IngestAliases []string `json:"ingest_aliases"`
	Name          string   `json:"name"`
}

// CustomerAlert defines model for CustomerAlert.
type CustomerAlert struct {
	Alert Alert `json:"alert"`

	// CustomerStatus The status of the customer alert. If the alert is archived, null will be returned.
	CustomerStatus *CustomerAlertCustomerStatus `json:"customer_status"`
}

// CustomerAlertCustomerStatus The status of the customer alert. If the alert is archived, null will be returned.
type CustomerAlertCustomerStatus string

// CustomerConfig defines model for CustomerConfig.
type CustomerConfig struct {
	// SalesforceAccountId The Salesforce account ID for the customer
	SalesforceAccountId *string `json:"salesforce_account_id"`
}

// CustomerConfigPayload defines model for CustomerConfigPayload.
type CustomerConfigPayload struct {
	// SalesforceAccountId The Salesforce account ID for the customer
	SalesforceAccountId *string `json:"salesforce_account_id"`
}

// CustomerCreditTypeLedger defines model for CustomerCreditTypeLedger.
type CustomerCreditTypeLedger struct {
	CustomerId openapi_types.UUID `json:"customer_id"`
	Ledgers    []CreditTypeLedger `json:"ledgers"`
}

// CustomerDetail defines model for CustomerDetail.
type CustomerDetail struct {
	CustomFields   CustomField    `json:"custom_fields"`
	CustomerConfig CustomerConfig `json:"customer_config"`

	// ExternalId (deprecated, use ingest_aliases instead) the first ID (Metronome or ingest alias) that can be used in usage events
	ExternalId string `json:"external_id"`

	// Id the Metronome ID of the customer
	Id openapi_types.UUID `json:"id"`

	// IngestAliases aliases for this customer that can be used instead of the Metronome customer ID in usage events
	IngestAliases []string `json:"ingest_aliases"`
	Name          string   `json:"name"`
}

// CustomerPlan defines model for CustomerPlan.
type CustomerPlan struct {
	EndingBefore        *time.Time         `json:"ending_before,omitempty"`
	Id                  openapi_types.UUID `json:"id"`
	NetPaymentTermsDays *float32           `json:"net_payment_terms_days,omitempty"`
	PlanId              openapi_types.UUID `json:"plan_id"`
	PlanName            string             `json:"plan_name"`
	StartingOn          time.Time          `json:"starting_on"`
	TrialInfo           *struct {
		EndingBefore string `json:"ending_before"`
		SpendingCaps []struct {
			Amount          float32    `json:"amount"`
			AmountRemaining float32    `json:"amount_remaining"`
			CreditType      CreditType `json:"credit_type"`
		} `json:"spending_caps"`
	} `json:"trial_info,omitempty"`
}

// EmbeddableDashboardPayload defines model for EmbeddableDashboardPayload.
type EmbeddableDashboardPayload struct {
	// ColorOverrides Optional list of colors to override
	ColorOverrides *[]struct {
		// Name The color to override
		Name *EmbeddableDashboardPayloadColorOverridesName `json:"name,omitempty"`

		// Value Hex value representation of the color
		Value *string `json:"value,omitempty"`
	} `json:"color_overrides,omitempty"`
	CustomerId openapi_types.UUID `json:"customer_id"`

	// Dashboard The type of dashboard to retrieve.
	Dashboard EmbeddableDashboardPayloadDashboard `json:"dashboard"`
}

// EmbeddableDashboardPayloadColorOverridesName The color to override
type EmbeddableDashboardPayloadColorOverridesName string

// EmbeddableDashboardPayloadDashboard The type of dashboard to retrieve.
type EmbeddableDashboardPayloadDashboard string

// EndCustomerPlanPayload defines model for EndCustomerPlanPayload.
type EndCustomerPlanPayload struct {
	// EndingBefore RFC 3339 timestamp for when the plan ends (exclusive) for this customer. Must be at 0:00 UTC (midnight).
	EndingBefore time.Time `json:"ending_before"`
}

// Error defines model for Error.
type Error struct {
	Message string `json:"message"`
}

// Event defines model for Event.
type Event struct {
	CustomerId string                  `json:"customer_id"`
	EventType  string                  `json:"event_type"`
	Properties *map[string]interface{} `json:"properties,omitempty"`

	// Timestamp RFC 3339 formatted
	Timestamp     string `json:"timestamp"`
	TransactionId string `json:"transaction_id"`
}

// ExternalInvoice defines model for ExternalInvoice.
type ExternalInvoice struct {
	BillingProviderType BillingProviderType            `json:"billing_provider_type"`
	ExternalStatus      *ExternalInvoiceExternalStatus `json:"external_status,omitempty"`
	InvoiceId           string                         `json:"invoice_id"`
	IssuedAtTimestamp   time.Time                      `json:"issued_at_timestamp"`
}

// ExternalInvoiceExternalStatus defines model for ExternalInvoice.ExternalStatus.
type ExternalInvoiceExternalStatus string

// GetCustomerAlertPayload defines model for GetCustomerAlertPayload.
type GetCustomerAlertPayload struct {
	// AlertId The Metronome ID of the alert
	AlertId openapi_types.UUID `json:"alert_id"`

	// CustomerId The Metronome ID of the customer
	CustomerId openapi_types.UUID `json:"customer_id"`
}

// Id defines model for Id.
type Id struct {
	Id openapi_types.UUID `json:"id"`
}

// Invoice defines model for Invoice.
type Invoice struct {
	CreditType CreditType         `json:"credit_type"`
	CustomerId openapi_types.UUID `json:"customer_id"`

	// EndTimestamp End of the usage period this invoice covers (UTC)
	EndTimestamp       time.Time           `json:"end_timestamp"`
	ExternalInvoice    *ExternalInvoice    `json:"external_invoice,omitempty"`
	Id                 openapi_types.UUID  `json:"id"`
	InvoiceAdjustments []InvoiceAdjustment `json:"invoice_adjustments"`
	LineItems          []InvoiceLineItem   `json:"line_items"`
	PlanId             *openapi_types.UUID `json:"plan_id,omitempty"`
	PlanName           *string             `json:"plan_name,omitempty"`

	// StartTimestamp Beginning of the usage period this invoice covers (UTC)
	StartTimestamp time.Time     `json:"start_timestamp"`
	Status         InvoiceStatus `json:"status"`
	Subtotal       float32       `json:"subtotal"`
	Total          float32       `json:"total"`
}

// InvoiceAdjustment defines model for InvoiceAdjustment.
type InvoiceAdjustment struct {
	CreditType CreditType `json:"credit_type"`
	Name       string     `json:"name"`
	Total      float32    `json:"total"`
}

// InvoiceLineItem defines model for InvoiceLineItem.
type InvoiceLineItem struct {
	CreditType   CreditType           `json:"credit_type"`
	CustomFields CustomField          `json:"custom_fields"`
	GroupKey     *string              `json:"group_key,omitempty"`
	GroupValue   *string              `json:"group_value,omitempty"`
	Name         string               `json:"name"`
	ProductId    *openapi_types.UUID  `json:"product_id,omitempty"`
	Quantity     float32              `json:"quantity"`
	SubLineItems []InvoiceSubLineItem `json:"sub_line_items"`
	Total        float32              `json:"total"`
}

// InvoiceStatus defines model for InvoiceStatus.
type InvoiceStatus = string

// InvoiceSubLineItem defines model for InvoiceSubLineItem.
type InvoiceSubLineItem struct {
	ChargeId     *openapi_types.UUID `json:"charge_id,omitempty"`
	CustomFields CustomField         `json:"custom_fields"`
	Name         string              `json:"name"`

	// Price the unit price for this charge, present only if the charge is not tiered and the quantity is nonzero
	Price    *float32       `json:"price,omitempty"`
	Quantity float32        `json:"quantity"`
	Subtotal float32        `json:"subtotal"`
	Tiers    *[]InvoiceTier `json:"tiers,omitempty"`
}

// InvoiceTier defines model for InvoiceTier.
type InvoiceTier struct {
	Price    float32 `json:"price"`
	Quantity float32 `json:"quantity"`

	// StartingAt at what metric amount this tier begins
	StartingAt float32 `json:"starting_at"`
	Subtotal   float32 `json:"subtotal"`
}

// LineItemBreakdown defines model for LineItemBreakdown.
type LineItemBreakdown struct {
	Cost       float32 `json:"cost"`
	GroupKey   *string `json:"group_key,omitempty"`
	GroupValue *string `json:"group_value"`
	Name       string  `json:"name"`
}

// ListCreditGrantPayload defines model for ListCreditGrantPayload.
type ListCreditGrantPayload struct {
	// CreditGrantIds An array of credit grant IDs. If this is specified, neither credit_type_ids nor customer_ids may be specified.
	CreditGrantIds *[]openapi_types.UUID `json:"credit_grant_ids,omitempty"`

	// CreditTypeIds An array of credit type IDs. This must not be specified if credit_grant_ids is specified.
	CreditTypeIds *[]openapi_types.UUID `json:"credit_type_ids,omitempty"`

	// CustomerIds An array of Metronome customer IDs. This must not be specified if credit_grant_ids is specified.
	CustomerIds *[]openapi_types.UUID `json:"customer_ids,omitempty"`

	// EffectiveBefore Only return credit grants that are effective before this timestamp (exclusive).
	EffectiveBefore *time.Time `json:"effective_before,omitempty"`

	// NotExpiringBefore Only return credit grants that expire at or after this timestamp.
	NotExpiringBefore *time.Time `json:"not_expiring_before,omitempty"`
}

// ListCustomerAlertsPayload defines model for ListCustomerAlertsPayload.
type ListCustomerAlertsPayload struct {
	// AlertStatuses Optionally filter by alert status. If absent, only enabled alerts will be returned.
	AlertStatuses *[]ListCustomerAlertsPayloadAlertStatuses `json:"alert_statuses,omitempty"`

	// CustomerId The Metronome ID of the customer
	CustomerId openapi_types.UUID `json:"customer_id"`
}

// ListCustomerAlertsPayloadAlertStatuses defines model for ListCustomerAlertsPayload.AlertStatuses.
type ListCustomerAlertsPayloadAlertStatuses string

// ManagedEntity defines model for ManagedEntity.
type ManagedEntity string

// PagedUsageAggregate defines model for PagedUsageAggregate.
type PagedUsageAggregate struct {
	EndingBefore time.Time `json:"ending_before"`
	GroupKey     *string   `json:"group_key"`
	GroupValue   *string   `json:"group_value"`
	StartingOn   time.Time `json:"starting_on"`
	Value        *float32  `json:"value"`
}

// PagedUsageQueryPayload defines model for PagedUsageQueryPayload.
type PagedUsageQueryPayload struct {
	BillableMetricId openapi_types.UUID `json:"billable_metric_id"`

	// CurrentPeriod If true, will return the usage for the current billing period. Will return an error if the customer is currently uncontracted or starting_on and ending_before are specified when this is true.
	CurrentPeriod *bool              `json:"current_period,omitempty"`
	CustomerId    openapi_types.UUID `json:"customer_id"`
	EndingBefore  *time.Time         `json:"ending_before,omitempty"`
	GroupBy       *struct {
		// Key The name of the group_by key to use
		Key string `json:"key"`

		// Values Values of the group_by key to return in the query. Omit this if you'd like all values for the key returned.
		Values *[]string `json:"values,omitempty"`
	} `json:"group_by,omitempty"`
	StartingOn *time.Time `json:"starting_on,omitempty"`

	// WindowSize A window_size of "day" or "hour" will return the usage for the specified period segmented into daily or hourly aggregates. A window_size of "none" will return a single usage aggregate for the entirety of the specified period.
	WindowSize PagedUsageQueryPayloadWindowSize `json:"window_size"`
}

// PagedUsageQueryPayloadWindowSize A window_size of "day" or "hour" will return the usage for the specified period segmented into daily or hourly aggregates. A window_size of "none" will return a single usage aggregate for the entirety of the specified period.
type PagedUsageQueryPayloadWindowSize string

// Plan defines model for Plan.
type Plan struct {
	Description string             `json:"description"`
	Id          openapi_types.UUID `json:"id"`
	Name        string             `json:"name"`
}

// PlanCharge defines model for PlanCharge.
type PlanCharge struct {
	ChargeType ChargeType         `json:"charge_type"`
	CreditType CreditType         `json:"credit_type"`
	Id         openapi_types.UUID `json:"id"`
	Name       string             `json:"name"`
	Prices     []struct {
		CollectionInterval *float32 `json:"collection_interval,omitempty"`
		CollectionSchedule *string  `json:"collection_schedule,omitempty"`
		Quantity           *float32 `json:"quantity,omitempty"`

		// Tier Used in pricing tiers.  Indicates at what metric value the price applies.
		Tier  float32 `json:"tier"`
		Value float32 `json:"value"`
	} `json:"prices"`
	ProductName string   `json:"product_name"`
	Quantity    *float32 `json:"quantity,omitempty"`

	// StartPeriod Used in price ramps.  Indicates how many billing periods pass before the charge applies.
	StartPeriod *float32 `json:"start_period,omitempty"`

	// UnitConversion Specifies how quantities for usage based charges will be converted.
	UnitConversion *struct {
		// DivisionFactor The conversion factor
		DivisionFactor float32 `json:"division_factor"`

		// RoundingBehavior Whether usage should be rounded down or up to the nearest whole number. If null, quantity will be rounded to 20 decimal places.
		RoundingBehavior *PlanChargeUnitConversionRoundingBehavior `json:"rounding_behavior,omitempty"`
	} `json:"unit_conversion,omitempty"`
}

// PlanChargeUnitConversionRoundingBehavior Whether usage should be rounded down or up to the nearest whole number. If null, quantity will be rounded to 20 decimal places.
type PlanChargeUnitConversionRoundingBehavior string

// PlanDetail defines model for PlanDetail.
type PlanDetail struct {
	CreditGrants *[]struct {
		AmountGranted           float32    `json:"amount_granted"`
		AmountGrantedCreditType CreditType `json:"amount_granted_credit_type"`
		AmountPaid              float32    `json:"amount_paid"`
		AmountPaidCreditType    CreditType `json:"amount_paid_credit_type"`
		EffectiveDuration       float32    `json:"effective_duration"`
		Name                    string     `json:"name"`
		Priority                string     `json:"priority"`
		Reason                  *string    `json:"reason,omitempty"`
		RecurrenceDuration      *float32   `json:"recurrence_duration,omitempty"`
		RecurrenceInterval      *float32   `json:"recurrence_interval,omitempty"`
		SendInvoice             bool       `json:"send_invoice"`
	} `json:"credit_grants,omitempty"`
	Description *string            `json:"description,omitempty"`
	Id          openapi_types.UUID `json:"id"`
	Minimums    *[]struct {
		CreditType CreditType `json:"credit_type"`
		Name       string     `json:"name"`

		// StartPeriod Used in price ramps.  Indicates how many billing periods pass before the charge applies.
		StartPeriod float32 `json:"start_period"`
		Value       float32 `json:"value"`
	} `json:"minimums,omitempty"`
	Name string `json:"name"`
}

// PriceAdjustment defines model for PriceAdjustment.
type PriceAdjustment struct {
	ChargeId   openapi_types.UUID `json:"charge_id"`
	ChargeType ChargeType         `json:"charge_type"`
	Prices     []struct {
		// AdjustmentType Determines how the value will be applied.
		AdjustmentType PriceAdjustmentPricesAdjustmentType `json:"adjustment_type"`

		// Tier Used in pricing tiers.  Indicates at what metric value the price applies.
		Tier  *float32 `json:"tier,omitempty"`
		Value *float32 `json:"value,omitempty"`
	} `json:"prices"`
	Quantity    *float32 `json:"quantity,omitempty"`
	StartPeriod float32  `json:"start_period"`
}

// PriceAdjustmentPricesAdjustmentType Determines how the value will be applied.
type PriceAdjustmentPricesAdjustmentType string

// SetCustomerNamePayload defines model for SetCustomerNamePayload.
type SetCustomerNamePayload struct {
	// Name The new name for the customer
	Name string `json:"name"`
}

// SetIngestAliasesPayload defines model for SetIngestAliasesPayload.
type SetIngestAliasesPayload struct {
	IngestAliases []string `json:"ingest_aliases"`
}

// StripeCollectionMethod defines model for StripeCollectionMethod.
type StripeCollectionMethod string

// UsageBatchAggregate defines model for UsageBatchAggregate.
type UsageBatchAggregate struct {
	BillableMetricId   openapi_types.UUID `json:"billable_metric_id"`
	BillableMetricName string             `json:"billable_metric_name"`
	CustomerId         openapi_types.UUID `json:"customer_id"`
	EndTimestamp       time.Time          `json:"end_timestamp"`

	// Groups Values will be either a number or null. Null indicates that there were no matches for the group_by value.
	Groups         *map[string]float32 `json:"groups,omitempty"`
	StartTimestamp time.Time           `json:"start_timestamp"`
	Value          *float32            `json:"value"`
}

// UsageBatchQueryPayload defines model for UsageBatchQueryPayload.
type UsageBatchQueryPayload struct {
	// BillableMetrics A list of billable metrics to fetch usage for. If absent, all billable metrics will be returned.
	BillableMetrics *[]struct {
		GroupBy *struct {
			// Key The name of the group_by key to use
			Key string `json:"key"`

			// Values Values of the group_by key to return in the query. If this field is omitted, all available values will be returned, up to a maximum of 200.
			Values *[]string `json:"values,omitempty"`
		} `json:"group_by,omitempty"`
		Id openapi_types.UUID `json:"id"`
	} `json:"billable_metrics,omitempty"`

	// CustomerIds A list of Metronome customer IDs to fetch usage for. If absent, usage for all customers will be returned.
	CustomerIds  *[]openapi_types.UUID `json:"customer_ids,omitempty"`
	EndingBefore time.Time             `json:"ending_before"`
	StartingOn   time.Time             `json:"starting_on"`

	// WindowSize A window_size of "day" or "hour" will return the usage for the specified period segmented into daily or hourly aggregates. A window_size of "none" will return a single usage aggregate for the entirety of the specified period.
	WindowSize UsageBatchQueryPayloadWindowSize `json:"window_size"`
}

// UsageBatchQueryPayloadWindowSize A window_size of "day" or "hour" will return the usage for the specified period segmented into daily or hourly aggregates. A window_size of "none" will return a single usage aggregate for the entirety of the specified period.
type UsageBatchQueryPayloadWindowSize string

// BillingProviderTypeParam defines model for BillingProviderType.
type BillingProviderTypeParam = BillingProviderType

// CustomerId defines model for CustomerId.
type CustomerId = openapi_types.UUID

// CustomerPlanId defines model for CustomerPlanId.
type CustomerPlanId = openapi_types.UUID

// InvoiceId defines model for InvoiceId.
type InvoiceId = openapi_types.UUID

// InvoiceStatusParam defines model for InvoiceStatus.
type InvoiceStatusParam = string

// NextPage defines model for NextPage.
type NextPage = string

// PageLimit defines model for PageLimit.
type PageLimit = int

// PlanId defines model for PlanId.
type PlanId = openapi_types.UUID

// RequiredEndDate defines model for RequiredEndDate.
type RequiredEndDate = time.Time

// RequiredStartDate defines model for RequiredStartDate.
type RequiredStartDate = time.Time

// NotFound defines model for NotFound.
type NotFound = Error

// ListCreditTypesParams defines parameters for ListCreditTypes.
type ListCreditTypesParams struct {
	// Limit Max number of results that should be returned
	Limit *PageLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// NextPage Cursor that indicates where the next page of results should start.
	NextPage *NextPage `form:"next_page,omitempty" json:"next_page,omitempty"`
}

// ListCreditLedgerEntriesParams defines parameters for ListCreditLedgerEntries.
type ListCreditLedgerEntriesParams struct {
	// NextPage Cursor that indicates where the next page of results should start.
	NextPage *NextPage `form:"next_page,omitempty" json:"next_page,omitempty"`
}

// ListGrantsParams defines parameters for ListGrants.
type ListGrantsParams struct {
	// NextPage Cursor that indicates where the next page of results should start.
	NextPage *NextPage `form:"next_page,omitempty" json:"next_page,omitempty"`
}

// AddCustomFieldKeyJSONBody defines parameters for AddCustomFieldKey.
type AddCustomFieldKeyJSONBody struct {
	EnforceUniqueness bool          `json:"enforce_uniqueness"`
	Entity            ManagedEntity `json:"entity"`
	Key               string        `json:"key"`
}

// DeleteCustomFieldsJSONBody defines parameters for DeleteCustomFields.
type DeleteCustomFieldsJSONBody struct {
	Entity   ManagedEntity      `json:"entity"`
	EntityId openapi_types.UUID `json:"entity_id"`
	Keys     []string           `json:"keys"`
}

// ListCustomFieldKeysJSONBody defines parameters for ListCustomFieldKeys.
type ListCustomFieldKeysJSONBody struct {
	// Entities Optional list of entity types to return keys for
	Entities *[]ManagedEntity `json:"entities,omitempty"`
}

// DisableCustomFieldKeyJSONBody defines parameters for DisableCustomFieldKey.
type DisableCustomFieldKeyJSONBody struct {
	Entity ManagedEntity `json:"entity"`
	Key    string        `json:"key"`
}

// SetCustomFieldsJSONBody defines parameters for SetCustomFields.
type SetCustomFieldsJSONBody struct {
	CustomFields CustomField        `json:"custom_fields"`
	Entity       ManagedEntity      `json:"entity"`
	EntityId     openapi_types.UUID `json:"entity_id"`
}

// ListCustomerAlertsParams defines parameters for ListCustomerAlerts.
type ListCustomerAlertsParams struct {
	// NextPage Cursor that indicates where the next page of results should start.
	NextPage *NextPage `form:"next_page,omitempty" json:"next_page,omitempty"`
}

// ListCustomersParams defines parameters for ListCustomers.
type ListCustomersParams struct {
	// Limit Max number of results that should be returned
	Limit *PageLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// NextPage Cursor that indicates where the next page of results should start.
	NextPage *NextPage `form:"next_page,omitempty" json:"next_page,omitempty"`

	// IngestAlias Filter the customer list by ingest_alias
	IngestAlias *string `form:"ingest_alias,omitempty" json:"ingest_alias,omitempty"`

	// CustomerIds Filter the customer list by customer_id.  Up to 100 ids can be provided.
	CustomerIds *[]string `form:"customer_ids,omitempty" json:"customer_ids,omitempty"`
}

// ListBillableMetricsParams defines parameters for ListBillableMetrics.
type ListBillableMetricsParams struct {
	// Limit Max number of results that should be returned
	Limit *PageLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// NextPage Cursor that indicates where the next page of results should start.
	NextPage *NextPage `form:"next_page,omitempty" json:"next_page,omitempty"`

	// OnCurrentPlan If true, the list of metrics will be filtered to just ones that are on the customer's current plan
	OnCurrentPlan *bool `form:"on_current_plan,omitempty" json:"on_current_plan,omitempty"`
}

// SetBillingConfigForCustomerJSONBody defines parameters for SetBillingConfigForCustomer.
type SetBillingConfigForCustomerJSONBody struct {
	AwsProductCode            *string                 `json:"aws_product_code,omitempty"`
	AwsRegion                 *AwsRegion              `json:"aws_region,omitempty"`
	BillingProviderCustomerId string                  `json:"billing_provider_customer_id"`
	StripeCollectionMethod    *StripeCollectionMethod `json:"stripe_collection_method,omitempty"`
}

// GetCostsParams defines parameters for GetCosts.
type GetCostsParams struct {
	// StartingOn RFC 3339 timestamp (inclusive)
	StartingOn RequiredStartDate `form:"starting_on" json:"starting_on"`

	// EndingBefore RFC 3339 timestamp (exclusive)
	EndingBefore RequiredEndDate `form:"ending_before" json:"ending_before"`

	// Limit Max number of results that should be returned
	Limit *PageLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// NextPage Cursor that indicates where the next page of results should start.
	NextPage *NextPage `form:"next_page,omitempty" json:"next_page,omitempty"`
}

// ListInvoicesParams defines parameters for ListInvoices.
type ListInvoicesParams struct {
	// Limit Max number of results that should be returned
	Limit *PageLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// NextPage Cursor that indicates where the next page of results should start.
	NextPage *NextPage `form:"next_page,omitempty" json:"next_page,omitempty"`

	// Status Invoice status, e.g. DRAFT, FINALIZED, or VOID
	InvoiceStatusParam *InvoiceStatusParam `form:"status,omitempty" json:"status,omitempty"`

	// CreditTypeId Only return invoices for the specified credit type
	CreditTypeId *string `form:"credit_type_id,omitempty" json:"credit_type_id,omitempty"`

	// StartingOn RFC 3339 timestamp (inclusive). Invoices will only be returned for billing periods that start at or after this time.
	StartingOn *time.Time `form:"starting_on,omitempty" json:"starting_on,omitempty"`

	// EndingBefore RFC 3339 timestamp (exclusive). Invoices will only be returned for billing periods that end before this time.
	EndingBefore *time.Time `form:"ending_before,omitempty" json:"ending_before,omitempty"`
}

// ListInvoicesCachedParams defines parameters for ListInvoicesCached.
type ListInvoicesCachedParams struct {
	// Limit Max number of results that should be returned
	Limit *PageLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// NextPage Cursor that indicates where the next page of results should start.
	NextPage *NextPage `form:"next_page,omitempty" json:"next_page,omitempty"`

	// Status Invoice status, e.g. DRAFT, FINALIZED, or VOID
	InvoiceStatusParam *InvoiceStatusParam `form:"status,omitempty" json:"status,omitempty"`

	// CreditTypeId Only return invoices for the specified credit type
	CreditTypeId *string `form:"credit_type_id,omitempty" json:"credit_type_id,omitempty"`

	// StartingOn RFC 3339 timestamp (inclusive). Invoices will only be returned for billing periods that start at or after this time.
	StartingOn *time.Time `form:"starting_on,omitempty" json:"starting_on,omitempty"`

	// EndingBefore RFC 3339 timestamp (exclusive). Invoices will only be returned for billing periods that end before this time.
	EndingBefore *time.Time `form:"ending_before,omitempty" json:"ending_before,omitempty"`
}

// ListCustomerPlansParams defines parameters for ListCustomerPlans.
type ListCustomerPlansParams struct {
	// Limit Max number of results that should be returned
	Limit *PageLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// NextPage Cursor that indicates where the next page of results should start.
	NextPage *NextPage `form:"next_page,omitempty" json:"next_page,omitempty"`
}

// GetPlanPriceAdjustmentsParams defines parameters for GetPlanPriceAdjustments.
type GetPlanPriceAdjustmentsParams struct {
	// Limit Max number of results that should be returned
	Limit *PageLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// NextPage Cursor that indicates where the next page of results should start.
	NextPage *NextPage `form:"next_page,omitempty" json:"next_page,omitempty"`
}

// IngestJSONBody defines parameters for Ingest.
type IngestJSONBody = []Event

// GetPlanChargesParams defines parameters for GetPlanCharges.
type GetPlanChargesParams struct {
	// Limit Max number of results that should be returned
	Limit *PageLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// NextPage Cursor that indicates where the next page of results should start.
	NextPage *NextPage `form:"next_page,omitempty" json:"next_page,omitempty"`
}

// ListPlansParams defines parameters for ListPlans.
type ListPlansParams struct {
	// Limit Max number of results that should be returned
	Limit *PageLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// NextPage Cursor that indicates where the next page of results should start.
	NextPage *NextPage `form:"next_page,omitempty" json:"next_page,omitempty"`
}

// GetUsageBatchParams defines parameters for GetUsageBatch.
type GetUsageBatchParams struct {
	// NextPage Cursor that indicates where the next page of results should start.
	NextPage *NextPage `form:"next_page,omitempty" json:"next_page,omitempty"`
}

// GetPagedUsageParams defines parameters for GetPagedUsage.
type GetPagedUsageParams struct {
	// Limit Max number of results that should be returned
	Limit *PageLimit `form:"limit,omitempty" json:"limit,omitempty"`

	// NextPage Cursor that indicates where the next page of results should start.
	NextPage *NextPage `form:"next_page,omitempty" json:"next_page,omitempty"`
}

// ArchiveAlertJSONRequestBody defines body for ArchiveAlert for application/json ContentType.
type ArchiveAlertJSONRequestBody = Id

// CreateAlertJSONRequestBody defines body for CreateAlert for application/json ContentType.
type CreateAlertJSONRequestBody = CreateCustomerAlertPayload

// CreateGrantJSONRequestBody defines body for CreateGrant for application/json ContentType.
type CreateGrantJSONRequestBody = CreateCreditGrantPayload

// ListCreditLedgerEntriesJSONRequestBody defines body for ListCreditLedgerEntries for application/json ContentType.
type ListCreditLedgerEntriesJSONRequestBody = CreditLedgerEntriesQueryPayload

// ListGrantsJSONRequestBody defines body for ListGrants for application/json ContentType.
type ListGrantsJSONRequestBody = ListCreditGrantPayload

// VoidGrantJSONRequestBody defines body for VoidGrant for application/json ContentType.
type VoidGrantJSONRequestBody = Id

// AddCustomFieldKeyJSONRequestBody defines body for AddCustomFieldKey for application/json ContentType.
type AddCustomFieldKeyJSONRequestBody AddCustomFieldKeyJSONBody

// DeleteCustomFieldsJSONRequestBody defines body for DeleteCustomFields for application/json ContentType.
type DeleteCustomFieldsJSONRequestBody DeleteCustomFieldsJSONBody

// ListCustomFieldKeysJSONRequestBody defines body for ListCustomFieldKeys for application/json ContentType.
type ListCustomFieldKeysJSONRequestBody ListCustomFieldKeysJSONBody

// DisableCustomFieldKeyJSONRequestBody defines body for DisableCustomFieldKey for application/json ContentType.
type DisableCustomFieldKeyJSONRequestBody DisableCustomFieldKeyJSONBody

// SetCustomFieldsJSONRequestBody defines body for SetCustomFields for application/json ContentType.
type SetCustomFieldsJSONRequestBody SetCustomFieldsJSONBody

// GetCustomerAlertJSONRequestBody defines body for GetCustomerAlert for application/json ContentType.
type GetCustomerAlertJSONRequestBody = GetCustomerAlertPayload

// ListCustomerAlertsJSONRequestBody defines body for ListCustomerAlerts for application/json ContentType.
type ListCustomerAlertsJSONRequestBody = ListCustomerAlertsPayload

// CreateCustomerJSONRequestBody defines body for CreateCustomer for application/json ContentType.
type CreateCustomerJSONRequestBody = CreateCustomerPayload

// SetBillingConfigForCustomerJSONRequestBody defines body for SetBillingConfigForCustomer for application/json ContentType.
type SetBillingConfigForCustomerJSONRequestBody SetBillingConfigForCustomerJSONBody

// AddPlanToCustomerJSONRequestBody defines body for AddPlanToCustomer for application/json ContentType.
type AddPlanToCustomerJSONRequestBody = AddPlanToCustomerPayload

// EndCustomerPlanJSONRequestBody defines body for EndCustomerPlan for application/json ContentType.
type EndCustomerPlanJSONRequestBody = EndCustomerPlanPayload

// SetIngestAliasesJSONRequestBody defines body for SetIngestAliases for application/json ContentType.
type SetIngestAliasesJSONRequestBody = SetIngestAliasesPayload

// SetCustomerNameJSONRequestBody defines body for SetCustomerName for application/json ContentType.
type SetCustomerNameJSONRequestBody = SetCustomerNamePayload

// UpdateCustomerConfigJSONRequestBody defines body for UpdateCustomerConfig for application/json ContentType.
type UpdateCustomerConfigJSONRequestBody = CustomerConfigPayload

// EmbeddableDashboardJSONRequestBody defines body for EmbeddableDashboard for application/json ContentType.
type EmbeddableDashboardJSONRequestBody = EmbeddableDashboardPayload

// IngestJSONRequestBody defines body for Ingest for application/json ContentType.
type IngestJSONRequestBody = IngestJSONBody

// GetUsageBatchJSONRequestBody defines body for GetUsageBatch for application/json ContentType.
type GetUsageBatchJSONRequestBody = UsageBatchQueryPayload

// GetPagedUsageJSONRequestBody defines body for GetPagedUsage for application/json ContentType.
type GetPagedUsageJSONRequestBody = PagedUsageQueryPayload

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ArchiveAlert request with any body
	ArchiveAlertWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ArchiveAlert(ctx context.Context, body ArchiveAlertJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAlert request with any body
	CreateAlertWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAlert(ctx context.Context, body CreateAlertJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCreditTypes request
	ListCreditTypes(ctx context.Context, params *ListCreditTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateGrant request with any body
	CreateGrantWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateGrant(ctx context.Context, body CreateGrantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCreditLedgerEntries request with any body
	ListCreditLedgerEntriesWithBody(ctx context.Context, params *ListCreditLedgerEntriesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListCreditLedgerEntries(ctx context.Context, params *ListCreditLedgerEntriesParams, body ListCreditLedgerEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListGrants request with any body
	ListGrantsWithBody(ctx context.Context, params *ListGrantsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListGrants(ctx context.Context, params *ListGrantsParams, body ListGrantsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VoidGrant request with any body
	VoidGrantWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	VoidGrant(ctx context.Context, body VoidGrantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddCustomFieldKey request with any body
	AddCustomFieldKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddCustomFieldKey(ctx context.Context, body AddCustomFieldKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCustomFields request with any body
	DeleteCustomFieldsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteCustomFields(ctx context.Context, body DeleteCustomFieldsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCustomFieldKeys request with any body
	ListCustomFieldKeysWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListCustomFieldKeys(ctx context.Context, body ListCustomFieldKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DisableCustomFieldKey request with any body
	DisableCustomFieldKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DisableCustomFieldKey(ctx context.Context, body DisableCustomFieldKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetCustomFields request with any body
	SetCustomFieldsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetCustomFields(ctx context.Context, body SetCustomFieldsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomerAlert request with any body
	GetCustomerAlertWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetCustomerAlert(ctx context.Context, body GetCustomerAlertJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCustomerAlerts request with any body
	ListCustomerAlertsWithBody(ctx context.Context, params *ListCustomerAlertsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ListCustomerAlerts(ctx context.Context, params *ListCustomerAlertsParams, body ListCustomerAlertsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCustomers request
	ListCustomers(ctx context.Context, params *ListCustomersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCustomer request with any body
	CreateCustomerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCustomer(ctx context.Context, body CreateCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCustomer request
	GetCustomer(ctx context.Context, customerId CustomerId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListBillableMetrics request
	ListBillableMetrics(ctx context.Context, customerId CustomerId, params *ListBillableMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteBillingConfigForCustomer request
	DeleteBillingConfigForCustomer(ctx context.Context, customerId CustomerId, billingProviderTypeParam BillingProviderTypeParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBillingConfig request
	GetBillingConfig(ctx context.Context, customerId CustomerId, billingProviderTypeParam BillingProviderTypeParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetBillingConfigForCustomer request with any body
	SetBillingConfigForCustomerWithBody(ctx context.Context, customerId CustomerId, billingProviderTypeParam BillingProviderTypeParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetBillingConfigForCustomer(ctx context.Context, customerId CustomerId, billingProviderTypeParam BillingProviderTypeParam, body SetBillingConfigForCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCosts request
	GetCosts(ctx context.Context, customerId CustomerId, params *GetCostsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListInvoices request
	ListInvoices(ctx context.Context, customerId CustomerId, params *ListInvoicesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListInvoicesCached request
	ListInvoicesCached(ctx context.Context, customerId CustomerId, params *ListInvoicesCachedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetInvoice request
	GetInvoice(ctx context.Context, customerId CustomerId, invoiceId InvoiceId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListCustomerPlans request
	ListCustomerPlans(ctx context.Context, customerId CustomerId, params *ListCustomerPlansParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddPlanToCustomer request with any body
	AddPlanToCustomerWithBody(ctx context.Context, customerId CustomerId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddPlanToCustomer(ctx context.Context, customerId CustomerId, body AddPlanToCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EndCustomerPlan request with any body
	EndCustomerPlanWithBody(ctx context.Context, customerId CustomerId, customerPlanId CustomerPlanId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EndCustomerPlan(ctx context.Context, customerId CustomerId, customerPlanId CustomerPlanId, body EndCustomerPlanJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlanPriceAdjustments request
	GetPlanPriceAdjustments(ctx context.Context, customerId CustomerId, customerPlanId CustomerPlanId, params *GetPlanPriceAdjustmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetIngestAliases request with any body
	SetIngestAliasesWithBody(ctx context.Context, customerId CustomerId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetIngestAliases(ctx context.Context, customerId CustomerId, body SetIngestAliasesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetCustomerName request with any body
	SetCustomerNameWithBody(ctx context.Context, customerId CustomerId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetCustomerName(ctx context.Context, customerId CustomerId, body SetCustomerNameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCustomerConfig request with any body
	UpdateCustomerConfigWithBody(ctx context.Context, customerId CustomerId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCustomerConfig(ctx context.Context, customerId CustomerId, body UpdateCustomerConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EmbeddableDashboard request with any body
	EmbeddableDashboardWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EmbeddableDashboard(ctx context.Context, body EmbeddableDashboardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Ingest request with any body
	IngestWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	Ingest(ctx context.Context, body IngestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlanDetails request
	GetPlanDetails(ctx context.Context, planId PlanId, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlanCharges request
	GetPlanCharges(ctx context.Context, planId PlanId, params *GetPlanChargesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPlans request
	ListPlans(ctx context.Context, params *ListPlansParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsageBatch request with any body
	GetUsageBatchWithBody(ctx context.Context, params *GetUsageBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetUsageBatch(ctx context.Context, params *GetUsageBatchParams, body GetUsageBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPagedUsage request with any body
	GetPagedUsageWithBody(ctx context.Context, params *GetPagedUsageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	GetPagedUsage(ctx context.Context, params *GetPagedUsageParams, body GetPagedUsageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ArchiveAlertWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveAlertRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ArchiveAlert(ctx context.Context, body ArchiveAlertJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewArchiveAlertRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAlertWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAlertRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAlert(ctx context.Context, body CreateAlertJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAlertRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCreditTypes(ctx context.Context, params *ListCreditTypesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCreditTypesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGrantWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGrantRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateGrant(ctx context.Context, body CreateGrantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateGrantRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCreditLedgerEntriesWithBody(ctx context.Context, params *ListCreditLedgerEntriesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCreditLedgerEntriesRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCreditLedgerEntries(ctx context.Context, params *ListCreditLedgerEntriesParams, body ListCreditLedgerEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCreditLedgerEntriesRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGrantsWithBody(ctx context.Context, params *ListGrantsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGrantsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListGrants(ctx context.Context, params *ListGrantsParams, body ListGrantsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListGrantsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VoidGrantWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVoidGrantRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VoidGrant(ctx context.Context, body VoidGrantJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVoidGrantRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddCustomFieldKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddCustomFieldKeyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddCustomFieldKey(ctx context.Context, body AddCustomFieldKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddCustomFieldKeyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCustomFieldsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCustomFieldsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCustomFields(ctx context.Context, body DeleteCustomFieldsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCustomFieldsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCustomFieldKeysWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCustomFieldKeysRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCustomFieldKeys(ctx context.Context, body ListCustomFieldKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCustomFieldKeysRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisableCustomFieldKeyWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisableCustomFieldKeyRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisableCustomFieldKey(ctx context.Context, body DisableCustomFieldKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisableCustomFieldKeyRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetCustomFieldsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetCustomFieldsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetCustomFields(ctx context.Context, body SetCustomFieldsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetCustomFieldsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomerAlertWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomerAlertRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomerAlert(ctx context.Context, body GetCustomerAlertJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomerAlertRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCustomerAlertsWithBody(ctx context.Context, params *ListCustomerAlertsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCustomerAlertsRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCustomerAlerts(ctx context.Context, params *ListCustomerAlertsParams, body ListCustomerAlertsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCustomerAlertsRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCustomers(ctx context.Context, params *ListCustomersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCustomersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCustomerWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCustomerRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCustomer(ctx context.Context, body CreateCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCustomerRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCustomer(ctx context.Context, customerId CustomerId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCustomerRequest(c.Server, customerId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListBillableMetrics(ctx context.Context, customerId CustomerId, params *ListBillableMetricsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListBillableMetricsRequest(c.Server, customerId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteBillingConfigForCustomer(ctx context.Context, customerId CustomerId, billingProviderTypeParam BillingProviderTypeParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteBillingConfigForCustomerRequest(c.Server, customerId, billingProviderTypeParam)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBillingConfig(ctx context.Context, customerId CustomerId, billingProviderTypeParam BillingProviderTypeParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBillingConfigRequest(c.Server, customerId, billingProviderTypeParam)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetBillingConfigForCustomerWithBody(ctx context.Context, customerId CustomerId, billingProviderTypeParam BillingProviderTypeParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetBillingConfigForCustomerRequestWithBody(c.Server, customerId, billingProviderTypeParam, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetBillingConfigForCustomer(ctx context.Context, customerId CustomerId, billingProviderTypeParam BillingProviderTypeParam, body SetBillingConfigForCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetBillingConfigForCustomerRequest(c.Server, customerId, billingProviderTypeParam, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCosts(ctx context.Context, customerId CustomerId, params *GetCostsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCostsRequest(c.Server, customerId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListInvoices(ctx context.Context, customerId CustomerId, params *ListInvoicesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListInvoicesRequest(c.Server, customerId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListInvoicesCached(ctx context.Context, customerId CustomerId, params *ListInvoicesCachedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListInvoicesCachedRequest(c.Server, customerId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetInvoice(ctx context.Context, customerId CustomerId, invoiceId InvoiceId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetInvoiceRequest(c.Server, customerId, invoiceId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListCustomerPlans(ctx context.Context, customerId CustomerId, params *ListCustomerPlansParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCustomerPlansRequest(c.Server, customerId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddPlanToCustomerWithBody(ctx context.Context, customerId CustomerId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddPlanToCustomerRequestWithBody(c.Server, customerId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddPlanToCustomer(ctx context.Context, customerId CustomerId, body AddPlanToCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddPlanToCustomerRequest(c.Server, customerId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EndCustomerPlanWithBody(ctx context.Context, customerId CustomerId, customerPlanId CustomerPlanId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEndCustomerPlanRequestWithBody(c.Server, customerId, customerPlanId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EndCustomerPlan(ctx context.Context, customerId CustomerId, customerPlanId CustomerPlanId, body EndCustomerPlanJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEndCustomerPlanRequest(c.Server, customerId, customerPlanId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlanPriceAdjustments(ctx context.Context, customerId CustomerId, customerPlanId CustomerPlanId, params *GetPlanPriceAdjustmentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlanPriceAdjustmentsRequest(c.Server, customerId, customerPlanId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetIngestAliasesWithBody(ctx context.Context, customerId CustomerId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetIngestAliasesRequestWithBody(c.Server, customerId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetIngestAliases(ctx context.Context, customerId CustomerId, body SetIngestAliasesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetIngestAliasesRequest(c.Server, customerId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetCustomerNameWithBody(ctx context.Context, customerId CustomerId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetCustomerNameRequestWithBody(c.Server, customerId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetCustomerName(ctx context.Context, customerId CustomerId, body SetCustomerNameJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetCustomerNameRequest(c.Server, customerId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCustomerConfigWithBody(ctx context.Context, customerId CustomerId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCustomerConfigRequestWithBody(c.Server, customerId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCustomerConfig(ctx context.Context, customerId CustomerId, body UpdateCustomerConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCustomerConfigRequest(c.Server, customerId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EmbeddableDashboardWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEmbeddableDashboardRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EmbeddableDashboard(ctx context.Context, body EmbeddableDashboardJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEmbeddableDashboardRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IngestWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIngestRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Ingest(ctx context.Context, body IngestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIngestRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlanDetails(ctx context.Context, planId PlanId, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlanDetailsRequest(c.Server, planId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlanCharges(ctx context.Context, planId PlanId, params *GetPlanChargesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlanChargesRequest(c.Server, planId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPlans(ctx context.Context, params *ListPlansParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPlansRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsageBatchWithBody(ctx context.Context, params *GetUsageBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsageBatchRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsageBatch(ctx context.Context, params *GetUsageBatchParams, body GetUsageBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsageBatchRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPagedUsageWithBody(ctx context.Context, params *GetPagedUsageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPagedUsageRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPagedUsage(ctx context.Context, params *GetPagedUsageParams, body GetPagedUsageJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPagedUsageRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewArchiveAlertRequest calls the generic ArchiveAlert builder with application/json body
func NewArchiveAlertRequest(server string, body ArchiveAlertJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewArchiveAlertRequestWithBody(server, "application/json", bodyReader)
}

// NewArchiveAlertRequestWithBody generates requests for ArchiveAlert with any type of body
func NewArchiveAlertRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/alerts/archive")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateAlertRequest calls the generic CreateAlert builder with application/json body
func NewCreateAlertRequest(server string, body CreateAlertJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAlertRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAlertRequestWithBody generates requests for CreateAlert with any type of body
func NewCreateAlertRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/alerts/create")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListCreditTypesRequest generates requests for ListCreditTypes
func NewListCreditTypesRequest(server string, params *ListCreditTypesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/credit-types/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page", runtime.ParamLocationQuery, *params.NextPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateGrantRequest calls the generic CreateGrant builder with application/json body
func NewCreateGrantRequest(server string, body CreateGrantJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateGrantRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateGrantRequestWithBody generates requests for CreateGrant with any type of body
func NewCreateGrantRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/credits/createGrant")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListCreditLedgerEntriesRequest calls the generic ListCreditLedgerEntries builder with application/json body
func NewListCreditLedgerEntriesRequest(server string, params *ListCreditLedgerEntriesParams, body ListCreditLedgerEntriesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListCreditLedgerEntriesRequestWithBody(server, params, "application/json", bodyReader)
}

// NewListCreditLedgerEntriesRequestWithBody generates requests for ListCreditLedgerEntries with any type of body
func NewListCreditLedgerEntriesRequestWithBody(server string, params *ListCreditLedgerEntriesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/credits/listEntries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.NextPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page", runtime.ParamLocationQuery, *params.NextPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListGrantsRequest calls the generic ListGrants builder with application/json body
func NewListGrantsRequest(server string, params *ListGrantsParams, body ListGrantsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListGrantsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewListGrantsRequestWithBody generates requests for ListGrants with any type of body
func NewListGrantsRequestWithBody(server string, params *ListGrantsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/credits/listGrants")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.NextPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page", runtime.ParamLocationQuery, *params.NextPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewVoidGrantRequest calls the generic VoidGrant builder with application/json body
func NewVoidGrantRequest(server string, body VoidGrantJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVoidGrantRequestWithBody(server, "application/json", bodyReader)
}

// NewVoidGrantRequestWithBody generates requests for VoidGrant with any type of body
func NewVoidGrantRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/credits/voidGrant")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddCustomFieldKeyRequest calls the generic AddCustomFieldKey builder with application/json body
func NewAddCustomFieldKeyRequest(server string, body AddCustomFieldKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddCustomFieldKeyRequestWithBody(server, "application/json", bodyReader)
}

// NewAddCustomFieldKeyRequestWithBody generates requests for AddCustomFieldKey with any type of body
func NewAddCustomFieldKeyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customFields/addKey")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCustomFieldsRequest calls the generic DeleteCustomFields builder with application/json body
func NewDeleteCustomFieldsRequest(server string, body DeleteCustomFieldsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteCustomFieldsRequestWithBody(server, "application/json", bodyReader)
}

// NewDeleteCustomFieldsRequestWithBody generates requests for DeleteCustomFields with any type of body
func NewDeleteCustomFieldsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customFields/deleteValues")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListCustomFieldKeysRequest calls the generic ListCustomFieldKeys builder with application/json body
func NewListCustomFieldKeysRequest(server string, body ListCustomFieldKeysJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListCustomFieldKeysRequestWithBody(server, "application/json", bodyReader)
}

// NewListCustomFieldKeysRequestWithBody generates requests for ListCustomFieldKeys with any type of body
func NewListCustomFieldKeysRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customFields/listKeys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDisableCustomFieldKeyRequest calls the generic DisableCustomFieldKey builder with application/json body
func NewDisableCustomFieldKeyRequest(server string, body DisableCustomFieldKeyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDisableCustomFieldKeyRequestWithBody(server, "application/json", bodyReader)
}

// NewDisableCustomFieldKeyRequestWithBody generates requests for DisableCustomFieldKey with any type of body
func NewDisableCustomFieldKeyRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customFields/removeKey")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSetCustomFieldsRequest calls the generic SetCustomFields builder with application/json body
func NewSetCustomFieldsRequest(server string, body SetCustomFieldsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetCustomFieldsRequestWithBody(server, "application/json", bodyReader)
}

// NewSetCustomFieldsRequestWithBody generates requests for SetCustomFields with any type of body
func NewSetCustomFieldsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customFields/setValues")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCustomerAlertRequest calls the generic GetCustomerAlert builder with application/json body
func NewGetCustomerAlertRequest(server string, body GetCustomerAlertJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetCustomerAlertRequestWithBody(server, "application/json", bodyReader)
}

// NewGetCustomerAlertRequestWithBody generates requests for GetCustomerAlert with any type of body
func NewGetCustomerAlertRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customer-alerts/get")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListCustomerAlertsRequest calls the generic ListCustomerAlerts builder with application/json body
func NewListCustomerAlertsRequest(server string, params *ListCustomerAlertsParams, body ListCustomerAlertsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewListCustomerAlertsRequestWithBody(server, params, "application/json", bodyReader)
}

// NewListCustomerAlertsRequestWithBody generates requests for ListCustomerAlerts with any type of body
func NewListCustomerAlertsRequestWithBody(server string, params *ListCustomerAlertsParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customer-alerts/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.NextPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page", runtime.ParamLocationQuery, *params.NextPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListCustomersRequest generates requests for ListCustomers
func NewListCustomersRequest(server string, params *ListCustomersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page", runtime.ParamLocationQuery, *params.NextPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.IngestAlias != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ingest_alias", runtime.ParamLocationQuery, *params.IngestAlias); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CustomerIds != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "customer_ids", runtime.ParamLocationQuery, *params.CustomerIds); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCustomerRequest calls the generic CreateCustomer builder with application/json body
func NewCreateCustomerRequest(server string, body CreateCustomerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCustomerRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateCustomerRequestWithBody generates requests for CreateCustomer with any type of body
func NewCreateCustomerRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCustomerRequest generates requests for GetCustomer
func NewGetCustomerRequest(server string, customerId CustomerId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customer_id", runtime.ParamLocationPath, customerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListBillableMetricsRequest generates requests for ListBillableMetrics
func NewListBillableMetricsRequest(server string, customerId CustomerId, params *ListBillableMetricsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customer_id", runtime.ParamLocationPath, customerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customers/%s/billable-metrics", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page", runtime.ParamLocationQuery, *params.NextPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.OnCurrentPlan != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "on_current_plan", runtime.ParamLocationQuery, *params.OnCurrentPlan); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteBillingConfigForCustomerRequest generates requests for DeleteBillingConfigForCustomer
func NewDeleteBillingConfigForCustomerRequest(server string, customerId CustomerId, billingProviderTypeParam BillingProviderTypeParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customer_id", runtime.ParamLocationPath, customerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "billing_provider_type", runtime.ParamLocationPath, billingProviderTypeParam)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customers/%s/billing-config/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBillingConfigRequest generates requests for GetBillingConfig
func NewGetBillingConfigRequest(server string, customerId CustomerId, billingProviderTypeParam BillingProviderTypeParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customer_id", runtime.ParamLocationPath, customerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "billing_provider_type", runtime.ParamLocationPath, billingProviderTypeParam)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customers/%s/billing-config/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetBillingConfigForCustomerRequest calls the generic SetBillingConfigForCustomer builder with application/json body
func NewSetBillingConfigForCustomerRequest(server string, customerId CustomerId, billingProviderTypeParam BillingProviderTypeParam, body SetBillingConfigForCustomerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetBillingConfigForCustomerRequestWithBody(server, customerId, billingProviderTypeParam, "application/json", bodyReader)
}

// NewSetBillingConfigForCustomerRequestWithBody generates requests for SetBillingConfigForCustomer with any type of body
func NewSetBillingConfigForCustomerRequestWithBody(server string, customerId CustomerId, billingProviderTypeParam BillingProviderTypeParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customer_id", runtime.ParamLocationPath, customerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "billing_provider_type", runtime.ParamLocationPath, billingProviderTypeParam)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customers/%s/billing-config/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetCostsRequest generates requests for GetCosts
func NewGetCostsRequest(server string, customerId CustomerId, params *GetCostsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customer_id", runtime.ParamLocationPath, customerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customers/%s/costs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_on", runtime.ParamLocationQuery, params.StartingOn); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ending_before", runtime.ParamLocationQuery, params.EndingBefore); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page", runtime.ParamLocationQuery, *params.NextPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListInvoicesRequest generates requests for ListInvoices
func NewListInvoicesRequest(server string, customerId CustomerId, params *ListInvoicesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customer_id", runtime.ParamLocationPath, customerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customers/%s/invoices", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page", runtime.ParamLocationQuery, *params.NextPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.InvoiceStatusParam != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.InvoiceStatusParam); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CreditTypeId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "credit_type_id", runtime.ParamLocationQuery, *params.CreditTypeId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartingOn != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_on", runtime.ParamLocationQuery, *params.StartingOn); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndingBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ending_before", runtime.ParamLocationQuery, *params.EndingBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListInvoicesCachedRequest generates requests for ListInvoicesCached
func NewListInvoicesCachedRequest(server string, customerId CustomerId, params *ListInvoicesCachedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customer_id", runtime.ParamLocationPath, customerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customers/%s/invoices/cached", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page", runtime.ParamLocationQuery, *params.NextPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.InvoiceStatusParam != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.InvoiceStatusParam); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.CreditTypeId != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "credit_type_id", runtime.ParamLocationQuery, *params.CreditTypeId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.StartingOn != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "starting_on", runtime.ParamLocationQuery, *params.StartingOn); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.EndingBefore != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ending_before", runtime.ParamLocationQuery, *params.EndingBefore); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetInvoiceRequest generates requests for GetInvoice
func NewGetInvoiceRequest(server string, customerId CustomerId, invoiceId InvoiceId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customer_id", runtime.ParamLocationPath, customerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "invoice_id", runtime.ParamLocationPath, invoiceId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customers/%s/invoices/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListCustomerPlansRequest generates requests for ListCustomerPlans
func NewListCustomerPlansRequest(server string, customerId CustomerId, params *ListCustomerPlansParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customer_id", runtime.ParamLocationPath, customerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customers/%s/plans", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page", runtime.ParamLocationQuery, *params.NextPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddPlanToCustomerRequest calls the generic AddPlanToCustomer builder with application/json body
func NewAddPlanToCustomerRequest(server string, customerId CustomerId, body AddPlanToCustomerJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddPlanToCustomerRequestWithBody(server, customerId, "application/json", bodyReader)
}

// NewAddPlanToCustomerRequestWithBody generates requests for AddPlanToCustomer with any type of body
func NewAddPlanToCustomerRequestWithBody(server string, customerId CustomerId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customer_id", runtime.ParamLocationPath, customerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customers/%s/plans/add", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEndCustomerPlanRequest calls the generic EndCustomerPlan builder with application/json body
func NewEndCustomerPlanRequest(server string, customerId CustomerId, customerPlanId CustomerPlanId, body EndCustomerPlanJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEndCustomerPlanRequestWithBody(server, customerId, customerPlanId, "application/json", bodyReader)
}

// NewEndCustomerPlanRequestWithBody generates requests for EndCustomerPlan with any type of body
func NewEndCustomerPlanRequestWithBody(server string, customerId CustomerId, customerPlanId CustomerPlanId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customer_id", runtime.ParamLocationPath, customerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "customer_plan_id", runtime.ParamLocationPath, customerPlanId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customers/%s/plans/%s/end", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPlanPriceAdjustmentsRequest generates requests for GetPlanPriceAdjustments
func NewGetPlanPriceAdjustmentsRequest(server string, customerId CustomerId, customerPlanId CustomerPlanId, params *GetPlanPriceAdjustmentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customer_id", runtime.ParamLocationPath, customerId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "customer_plan_id", runtime.ParamLocationPath, customerPlanId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customers/%s/plans/%s/priceAdjustments", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page", runtime.ParamLocationQuery, *params.NextPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSetIngestAliasesRequest calls the generic SetIngestAliases builder with application/json body
func NewSetIngestAliasesRequest(server string, customerId CustomerId, body SetIngestAliasesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetIngestAliasesRequestWithBody(server, customerId, "application/json", bodyReader)
}

// NewSetIngestAliasesRequestWithBody generates requests for SetIngestAliases with any type of body
func NewSetIngestAliasesRequestWithBody(server string, customerId CustomerId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customer_id", runtime.ParamLocationPath, customerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customers/%s/setIngestAliases", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSetCustomerNameRequest calls the generic SetCustomerName builder with application/json body
func NewSetCustomerNameRequest(server string, customerId CustomerId, body SetCustomerNameJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetCustomerNameRequestWithBody(server, customerId, "application/json", bodyReader)
}

// NewSetCustomerNameRequestWithBody generates requests for SetCustomerName with any type of body
func NewSetCustomerNameRequestWithBody(server string, customerId CustomerId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customer_id", runtime.ParamLocationPath, customerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customers/%s/setName", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateCustomerConfigRequest calls the generic UpdateCustomerConfig builder with application/json body
func NewUpdateCustomerConfigRequest(server string, customerId CustomerId, body UpdateCustomerConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCustomerConfigRequestWithBody(server, customerId, "application/json", bodyReader)
}

// NewUpdateCustomerConfigRequestWithBody generates requests for UpdateCustomerConfig with any type of body
func NewUpdateCustomerConfigRequestWithBody(server string, customerId CustomerId, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "customer_id", runtime.ParamLocationPath, customerId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/customers/%s/updateConfig", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEmbeddableDashboardRequest calls the generic EmbeddableDashboard builder with application/json body
func NewEmbeddableDashboardRequest(server string, body EmbeddableDashboardJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEmbeddableDashboardRequestWithBody(server, "application/json", bodyReader)
}

// NewEmbeddableDashboardRequestWithBody generates requests for EmbeddableDashboard with any type of body
func NewEmbeddableDashboardRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/dashboards/getEmbeddableUrl")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewIngestRequest calls the generic Ingest builder with application/json body
func NewIngestRequest(server string, body IngestJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewIngestRequestWithBody(server, "application/json", bodyReader)
}

// NewIngestRequestWithBody generates requests for Ingest with any type of body
func NewIngestRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ingest")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPlanDetailsRequest generates requests for GetPlanDetails
func NewGetPlanDetailsRequest(server string, planId PlanId) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "plan_id", runtime.ParamLocationPath, planId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/planDetails/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlanChargesRequest generates requests for GetPlanCharges
func NewGetPlanChargesRequest(server string, planId PlanId, params *GetPlanChargesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "plan_id", runtime.ParamLocationPath, planId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/planDetails/%s/charges", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page", runtime.ParamLocationQuery, *params.NextPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPlansRequest generates requests for ListPlans
func NewListPlansRequest(server string, params *ListPlansParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/plans")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page", runtime.ParamLocationQuery, *params.NextPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsageBatchRequest calls the generic GetUsageBatch builder with application/json body
func NewGetUsageBatchRequest(server string, params *GetUsageBatchParams, body GetUsageBatchJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetUsageBatchRequestWithBody(server, params, "application/json", bodyReader)
}

// NewGetUsageBatchRequestWithBody generates requests for GetUsageBatch with any type of body
func NewGetUsageBatchRequestWithBody(server string, params *GetUsageBatchParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/usage")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.NextPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page", runtime.ParamLocationQuery, *params.NextPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPagedUsageRequest calls the generic GetPagedUsage builder with application/json body
func NewGetPagedUsageRequest(server string, params *GetPagedUsageParams, body GetPagedUsageJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetPagedUsageRequestWithBody(server, params, "application/json", bodyReader)
}

// NewGetPagedUsageRequestWithBody generates requests for GetPagedUsage with any type of body
func NewGetPagedUsageRequestWithBody(server string, params *GetPagedUsageParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/usage/groups")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	queryValues := queryURL.Query()

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.NextPage != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next_page", runtime.ParamLocationQuery, *params.NextPage); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ArchiveAlert request with any body
	ArchiveAlertWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveAlertResponse, error)

	ArchiveAlertWithResponse(ctx context.Context, body ArchiveAlertJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveAlertResponse, error)

	// CreateAlert request with any body
	CreateAlertWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAlertResponse, error)

	CreateAlertWithResponse(ctx context.Context, body CreateAlertJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAlertResponse, error)

	// ListCreditTypes request
	ListCreditTypesWithResponse(ctx context.Context, params *ListCreditTypesParams, reqEditors ...RequestEditorFn) (*ListCreditTypesResponse, error)

	// CreateGrant request with any body
	CreateGrantWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGrantResponse, error)

	CreateGrantWithResponse(ctx context.Context, body CreateGrantJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGrantResponse, error)

	// ListCreditLedgerEntries request with any body
	ListCreditLedgerEntriesWithBodyWithResponse(ctx context.Context, params *ListCreditLedgerEntriesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListCreditLedgerEntriesResponse, error)

	ListCreditLedgerEntriesWithResponse(ctx context.Context, params *ListCreditLedgerEntriesParams, body ListCreditLedgerEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*ListCreditLedgerEntriesResponse, error)

	// ListGrants request with any body
	ListGrantsWithBodyWithResponse(ctx context.Context, params *ListGrantsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListGrantsResponse, error)

	ListGrantsWithResponse(ctx context.Context, params *ListGrantsParams, body ListGrantsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListGrantsResponse, error)

	// VoidGrant request with any body
	VoidGrantWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VoidGrantResponse, error)

	VoidGrantWithResponse(ctx context.Context, body VoidGrantJSONRequestBody, reqEditors ...RequestEditorFn) (*VoidGrantResponse, error)

	// AddCustomFieldKey request with any body
	AddCustomFieldKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddCustomFieldKeyResponse, error)

	AddCustomFieldKeyWithResponse(ctx context.Context, body AddCustomFieldKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*AddCustomFieldKeyResponse, error)

	// DeleteCustomFields request with any body
	DeleteCustomFieldsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteCustomFieldsResponse, error)

	DeleteCustomFieldsWithResponse(ctx context.Context, body DeleteCustomFieldsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteCustomFieldsResponse, error)

	// ListCustomFieldKeys request with any body
	ListCustomFieldKeysWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListCustomFieldKeysResponse, error)

	ListCustomFieldKeysWithResponse(ctx context.Context, body ListCustomFieldKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*ListCustomFieldKeysResponse, error)

	// DisableCustomFieldKey request with any body
	DisableCustomFieldKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DisableCustomFieldKeyResponse, error)

	DisableCustomFieldKeyWithResponse(ctx context.Context, body DisableCustomFieldKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*DisableCustomFieldKeyResponse, error)

	// SetCustomFields request with any body
	SetCustomFieldsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetCustomFieldsResponse, error)

	SetCustomFieldsWithResponse(ctx context.Context, body SetCustomFieldsJSONRequestBody, reqEditors ...RequestEditorFn) (*SetCustomFieldsResponse, error)

	// GetCustomerAlert request with any body
	GetCustomerAlertWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetCustomerAlertResponse, error)

	GetCustomerAlertWithResponse(ctx context.Context, body GetCustomerAlertJSONRequestBody, reqEditors ...RequestEditorFn) (*GetCustomerAlertResponse, error)

	// ListCustomerAlerts request with any body
	ListCustomerAlertsWithBodyWithResponse(ctx context.Context, params *ListCustomerAlertsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListCustomerAlertsResponse, error)

	ListCustomerAlertsWithResponse(ctx context.Context, params *ListCustomerAlertsParams, body ListCustomerAlertsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListCustomerAlertsResponse, error)

	// ListCustomers request
	ListCustomersWithResponse(ctx context.Context, params *ListCustomersParams, reqEditors ...RequestEditorFn) (*ListCustomersResponse, error)

	// CreateCustomer request with any body
	CreateCustomerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCustomerResponse, error)

	CreateCustomerWithResponse(ctx context.Context, body CreateCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCustomerResponse, error)

	// GetCustomer request
	GetCustomerWithResponse(ctx context.Context, customerId CustomerId, reqEditors ...RequestEditorFn) (*GetCustomerResponse, error)

	// ListBillableMetrics request
	ListBillableMetricsWithResponse(ctx context.Context, customerId CustomerId, params *ListBillableMetricsParams, reqEditors ...RequestEditorFn) (*ListBillableMetricsResponse, error)

	// DeleteBillingConfigForCustomer request
	DeleteBillingConfigForCustomerWithResponse(ctx context.Context, customerId CustomerId, billingProviderTypeParam BillingProviderTypeParam, reqEditors ...RequestEditorFn) (*DeleteBillingConfigForCustomerResponse, error)

	// GetBillingConfig request
	GetBillingConfigWithResponse(ctx context.Context, customerId CustomerId, billingProviderTypeParam BillingProviderTypeParam, reqEditors ...RequestEditorFn) (*GetBillingConfigResponse, error)

	// SetBillingConfigForCustomer request with any body
	SetBillingConfigForCustomerWithBodyWithResponse(ctx context.Context, customerId CustomerId, billingProviderTypeParam BillingProviderTypeParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetBillingConfigForCustomerResponse, error)

	SetBillingConfigForCustomerWithResponse(ctx context.Context, customerId CustomerId, billingProviderTypeParam BillingProviderTypeParam, body SetBillingConfigForCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*SetBillingConfigForCustomerResponse, error)

	// GetCosts request
	GetCostsWithResponse(ctx context.Context, customerId CustomerId, params *GetCostsParams, reqEditors ...RequestEditorFn) (*GetCostsResponse, error)

	// ListInvoices request
	ListInvoicesWithResponse(ctx context.Context, customerId CustomerId, params *ListInvoicesParams, reqEditors ...RequestEditorFn) (*ListInvoicesResponse, error)

	// ListInvoicesCached request
	ListInvoicesCachedWithResponse(ctx context.Context, customerId CustomerId, params *ListInvoicesCachedParams, reqEditors ...RequestEditorFn) (*ListInvoicesCachedResponse, error)

	// GetInvoice request
	GetInvoiceWithResponse(ctx context.Context, customerId CustomerId, invoiceId InvoiceId, reqEditors ...RequestEditorFn) (*GetInvoiceResponse, error)

	// ListCustomerPlans request
	ListCustomerPlansWithResponse(ctx context.Context, customerId CustomerId, params *ListCustomerPlansParams, reqEditors ...RequestEditorFn) (*ListCustomerPlansResponse, error)

	// AddPlanToCustomer request with any body
	AddPlanToCustomerWithBodyWithResponse(ctx context.Context, customerId CustomerId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddPlanToCustomerResponse, error)

	AddPlanToCustomerWithResponse(ctx context.Context, customerId CustomerId, body AddPlanToCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*AddPlanToCustomerResponse, error)

	// EndCustomerPlan request with any body
	EndCustomerPlanWithBodyWithResponse(ctx context.Context, customerId CustomerId, customerPlanId CustomerPlanId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EndCustomerPlanResponse, error)

	EndCustomerPlanWithResponse(ctx context.Context, customerId CustomerId, customerPlanId CustomerPlanId, body EndCustomerPlanJSONRequestBody, reqEditors ...RequestEditorFn) (*EndCustomerPlanResponse, error)

	// GetPlanPriceAdjustments request
	GetPlanPriceAdjustmentsWithResponse(ctx context.Context, customerId CustomerId, customerPlanId CustomerPlanId, params *GetPlanPriceAdjustmentsParams, reqEditors ...RequestEditorFn) (*GetPlanPriceAdjustmentsResponse, error)

	// SetIngestAliases request with any body
	SetIngestAliasesWithBodyWithResponse(ctx context.Context, customerId CustomerId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetIngestAliasesResponse, error)

	SetIngestAliasesWithResponse(ctx context.Context, customerId CustomerId, body SetIngestAliasesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetIngestAliasesResponse, error)

	// SetCustomerName request with any body
	SetCustomerNameWithBodyWithResponse(ctx context.Context, customerId CustomerId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetCustomerNameResponse, error)

	SetCustomerNameWithResponse(ctx context.Context, customerId CustomerId, body SetCustomerNameJSONRequestBody, reqEditors ...RequestEditorFn) (*SetCustomerNameResponse, error)

	// UpdateCustomerConfig request with any body
	UpdateCustomerConfigWithBodyWithResponse(ctx context.Context, customerId CustomerId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCustomerConfigResponse, error)

	UpdateCustomerConfigWithResponse(ctx context.Context, customerId CustomerId, body UpdateCustomerConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCustomerConfigResponse, error)

	// EmbeddableDashboard request with any body
	EmbeddableDashboardWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EmbeddableDashboardResponse, error)

	EmbeddableDashboardWithResponse(ctx context.Context, body EmbeddableDashboardJSONRequestBody, reqEditors ...RequestEditorFn) (*EmbeddableDashboardResponse, error)

	// Ingest request with any body
	IngestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IngestResponse, error)

	IngestWithResponse(ctx context.Context, body IngestJSONRequestBody, reqEditors ...RequestEditorFn) (*IngestResponse, error)

	// GetPlanDetails request
	GetPlanDetailsWithResponse(ctx context.Context, planId PlanId, reqEditors ...RequestEditorFn) (*GetPlanDetailsResponse, error)

	// GetPlanCharges request
	GetPlanChargesWithResponse(ctx context.Context, planId PlanId, params *GetPlanChargesParams, reqEditors ...RequestEditorFn) (*GetPlanChargesResponse, error)

	// ListPlans request
	ListPlansWithResponse(ctx context.Context, params *ListPlansParams, reqEditors ...RequestEditorFn) (*ListPlansResponse, error)

	// GetUsageBatch request with any body
	GetUsageBatchWithBodyWithResponse(ctx context.Context, params *GetUsageBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetUsageBatchResponse, error)

	GetUsageBatchWithResponse(ctx context.Context, params *GetUsageBatchParams, body GetUsageBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*GetUsageBatchResponse, error)

	// GetPagedUsage request with any body
	GetPagedUsageWithBodyWithResponse(ctx context.Context, params *GetPagedUsageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetPagedUsageResponse, error)

	GetPagedUsageWithResponse(ctx context.Context, params *GetPagedUsageParams, body GetPagedUsageJSONRequestBody, reqEditors ...RequestEditorFn) (*GetPagedUsageResponse, error)
}

type ArchiveAlertResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data Id `json:"data"`
	}
	JSON404 *Error
}

// Status returns HTTPResponse.Status
func (r ArchiveAlertResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ArchiveAlertResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAlertResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data Id `json:"data"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateAlertResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAlertResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCreditTypesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []struct {
			Id         *openapi_types.UUID `json:"id,omitempty"`
			IsCurrency *bool               `json:"is_currency,omitempty"`
			Name       *string             `json:"name,omitempty"`
		} `json:"data"`
		NextPage *string `json:"next_page"`
	}
}

// Status returns HTTPResponse.Status
func (r ListCreditTypesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCreditTypesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateGrantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data Id `json:"data"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateGrantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateGrantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCreditLedgerEntriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data     []CustomerCreditTypeLedger `json:"data"`
		NextPage *string                    `json:"next_page"`
	}
	JSON404 *Error
}

// Status returns HTTPResponse.Status
func (r ListCreditLedgerEntriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCreditLedgerEntriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListGrantsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data     []CreditGrant `json:"data"`
		NextPage *string       `json:"next_page"`
	}
}

// Status returns HTTPResponse.Status
func (r ListGrantsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListGrantsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VoidGrantResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data Id `json:"data"`
	}
	JSON400 *Error
}

// Status returns HTTPResponse.Status
func (r VoidGrantResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VoidGrantResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddCustomFieldKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r AddCustomFieldKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddCustomFieldKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCustomFieldsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteCustomFieldsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCustomFieldsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCustomFieldKeysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []struct {
			EnforceUniqueness bool          `json:"enforce_uniqueness"`
			Entity            ManagedEntity `json:"entity"`
			Key               string        `json:"key"`
		} `json:"data"`
		NextPage *string `json:"next_page"`
	}
}

// Status returns HTTPResponse.Status
func (r ListCustomFieldKeysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCustomFieldKeysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DisableCustomFieldKeyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DisableCustomFieldKeyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DisableCustomFieldKeyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetCustomFieldsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetCustomFieldsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetCustomFieldsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomerAlertResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data CustomerAlert `json:"data"`
	}
	JSON404 *Error
}

// Status returns HTTPResponse.Status
func (r GetCustomerAlertResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomerAlertResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCustomerAlertsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data     []CustomerAlert `json:"data"`
		NextPage *string         `json:"next_page"`
	}
}

// Status returns HTTPResponse.Status
func (r ListCustomerAlertsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCustomerAlertsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCustomersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data     []CustomerDetail `json:"data"`
		NextPage *string          `json:"next_page"`
	}
}

// Status returns HTTPResponse.Status
func (r ListCustomersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCustomersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCustomerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data Customer `json:"data"`
	}
	JSON409 *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateCustomerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCustomerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCustomerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data CustomerDetail `json:"data"`
	}
}

// Status returns HTTPResponse.Status
func (r GetCustomerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListBillableMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data     []BillableMetric `json:"data"`
		NextPage *string          `json:"next_page"`
	}
}

// Status returns HTTPResponse.Status
func (r ListBillableMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListBillableMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteBillingConfigForCustomerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteBillingConfigForCustomerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteBillingConfigForCustomerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBillingConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data struct {
			// AwsExpirationDate Contract expiration date for the customer. The expected format is RFC 3339 and can be retrieved from AWS's GetEntitlements API. (See https://docs.aws.amazon.com/marketplaceentitlement/latest/APIReference/API_GetEntitlements.html.)
			AwsExpirationDate         *AwsExpirationDate      `json:"aws_expiration_date,omitempty"`
			AwsProductCode            *string                 `json:"aws_product_code,omitempty"`
			AwsRegion                 *AwsRegion              `json:"aws_region,omitempty"`
			BillingProviderCustomerId *string                 `json:"billing_provider_customer_id,omitempty"`
			StripeCollectionMethod    *StripeCollectionMethod `json:"stripe_collection_method,omitempty"`
		} `json:"data"`
	}
	JSON404 *Error
}

// Status returns HTTPResponse.Status
func (r GetBillingConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBillingConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetBillingConfigForCustomerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r SetBillingConfigForCustomerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetBillingConfigForCustomerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCostsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data     []Costs `json:"data"`
		NextPage *string `json:"next_page"`
	}
	JSON400 *Error
	JSON404 *Error
}

// Status returns HTTPResponse.Status
func (r GetCostsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCostsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListInvoicesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data     []Invoice `json:"data"`
		NextPage *string   `json:"next_page"`
	}
	JSON404 *Error
}

// Status returns HTTPResponse.Status
func (r ListInvoicesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListInvoicesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListInvoicesCachedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data     []Invoice `json:"data"`
		NextPage *string   `json:"next_page"`
	}
	JSON404 *Error
}

// Status returns HTTPResponse.Status
func (r ListInvoicesCachedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListInvoicesCachedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetInvoiceResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data Invoice `json:"data"`
	}
	JSON404 *Error
}

// Status returns HTTPResponse.Status
func (r GetInvoiceResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInvoiceResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListCustomerPlansResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data     []CustomerPlan `json:"data"`
		NextPage *string        `json:"next_page"`
	}
}

// Status returns HTTPResponse.Status
func (r ListCustomerPlansResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCustomerPlansResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddPlanToCustomerResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data Id `json:"data"`
	}
}

// Status returns HTTPResponse.Status
func (r AddPlanToCustomerResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddPlanToCustomerResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EndCustomerPlanResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r EndCustomerPlanResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EndCustomerPlanResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlanPriceAdjustmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data     []PriceAdjustment `json:"data"`
		NextPage *string           `json:"next_page"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPlanPriceAdjustmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlanPriceAdjustmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetIngestAliasesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetIngestAliasesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetIngestAliasesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetCustomerNameResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data Customer `json:"data"`
	}
}

// Status returns HTTPResponse.Status
func (r SetCustomerNameResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetCustomerNameResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCustomerConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *Error
	JSON404      *Error
}

// Status returns HTTPResponse.Status
func (r UpdateCustomerConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCustomerConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EmbeddableDashboardResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data struct {
			Url *string `json:"url,omitempty"`
		} `json:"data"`
	}
	JSON400 *Error
}

// Status returns HTTPResponse.Status
func (r EmbeddableDashboardResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EmbeddableDashboardResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IngestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r IngestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IngestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlanDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data PlanDetail `json:"data"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPlanDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlanDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlanChargesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data     []PlanCharge `json:"data"`
		NextPage *string      `json:"next_page"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPlanChargesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlanChargesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPlansResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data     []Plan  `json:"data"`
		NextPage *string `json:"next_page"`
	}
}

// Status returns HTTPResponse.Status
func (r ListPlansResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPlansResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsageBatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data     []UsageBatchAggregate `json:"data"`
		NextPage *string               `json:"next_page"`
	}
}

// Status returns HTTPResponse.Status
func (r GetUsageBatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsageBatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPagedUsageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data     []PagedUsageAggregate `json:"data"`
		NextPage *string               `json:"next_page"`
	}
}

// Status returns HTTPResponse.Status
func (r GetPagedUsageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPagedUsageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ArchiveAlertWithBodyWithResponse request with arbitrary body returning *ArchiveAlertResponse
func (c *ClientWithResponses) ArchiveAlertWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ArchiveAlertResponse, error) {
	rsp, err := c.ArchiveAlertWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveAlertResponse(rsp)
}

func (c *ClientWithResponses) ArchiveAlertWithResponse(ctx context.Context, body ArchiveAlertJSONRequestBody, reqEditors ...RequestEditorFn) (*ArchiveAlertResponse, error) {
	rsp, err := c.ArchiveAlert(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseArchiveAlertResponse(rsp)
}

// CreateAlertWithBodyWithResponse request with arbitrary body returning *CreateAlertResponse
func (c *ClientWithResponses) CreateAlertWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAlertResponse, error) {
	rsp, err := c.CreateAlertWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAlertResponse(rsp)
}

func (c *ClientWithResponses) CreateAlertWithResponse(ctx context.Context, body CreateAlertJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAlertResponse, error) {
	rsp, err := c.CreateAlert(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAlertResponse(rsp)
}

// ListCreditTypesWithResponse request returning *ListCreditTypesResponse
func (c *ClientWithResponses) ListCreditTypesWithResponse(ctx context.Context, params *ListCreditTypesParams, reqEditors ...RequestEditorFn) (*ListCreditTypesResponse, error) {
	rsp, err := c.ListCreditTypes(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCreditTypesResponse(rsp)
}

// CreateGrantWithBodyWithResponse request with arbitrary body returning *CreateGrantResponse
func (c *ClientWithResponses) CreateGrantWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateGrantResponse, error) {
	rsp, err := c.CreateGrantWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGrantResponse(rsp)
}

func (c *ClientWithResponses) CreateGrantWithResponse(ctx context.Context, body CreateGrantJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateGrantResponse, error) {
	rsp, err := c.CreateGrant(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateGrantResponse(rsp)
}

// ListCreditLedgerEntriesWithBodyWithResponse request with arbitrary body returning *ListCreditLedgerEntriesResponse
func (c *ClientWithResponses) ListCreditLedgerEntriesWithBodyWithResponse(ctx context.Context, params *ListCreditLedgerEntriesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListCreditLedgerEntriesResponse, error) {
	rsp, err := c.ListCreditLedgerEntriesWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCreditLedgerEntriesResponse(rsp)
}

func (c *ClientWithResponses) ListCreditLedgerEntriesWithResponse(ctx context.Context, params *ListCreditLedgerEntriesParams, body ListCreditLedgerEntriesJSONRequestBody, reqEditors ...RequestEditorFn) (*ListCreditLedgerEntriesResponse, error) {
	rsp, err := c.ListCreditLedgerEntries(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCreditLedgerEntriesResponse(rsp)
}

// ListGrantsWithBodyWithResponse request with arbitrary body returning *ListGrantsResponse
func (c *ClientWithResponses) ListGrantsWithBodyWithResponse(ctx context.Context, params *ListGrantsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListGrantsResponse, error) {
	rsp, err := c.ListGrantsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGrantsResponse(rsp)
}

func (c *ClientWithResponses) ListGrantsWithResponse(ctx context.Context, params *ListGrantsParams, body ListGrantsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListGrantsResponse, error) {
	rsp, err := c.ListGrants(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListGrantsResponse(rsp)
}

// VoidGrantWithBodyWithResponse request with arbitrary body returning *VoidGrantResponse
func (c *ClientWithResponses) VoidGrantWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VoidGrantResponse, error) {
	rsp, err := c.VoidGrantWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVoidGrantResponse(rsp)
}

func (c *ClientWithResponses) VoidGrantWithResponse(ctx context.Context, body VoidGrantJSONRequestBody, reqEditors ...RequestEditorFn) (*VoidGrantResponse, error) {
	rsp, err := c.VoidGrant(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVoidGrantResponse(rsp)
}

// AddCustomFieldKeyWithBodyWithResponse request with arbitrary body returning *AddCustomFieldKeyResponse
func (c *ClientWithResponses) AddCustomFieldKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddCustomFieldKeyResponse, error) {
	rsp, err := c.AddCustomFieldKeyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddCustomFieldKeyResponse(rsp)
}

func (c *ClientWithResponses) AddCustomFieldKeyWithResponse(ctx context.Context, body AddCustomFieldKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*AddCustomFieldKeyResponse, error) {
	rsp, err := c.AddCustomFieldKey(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddCustomFieldKeyResponse(rsp)
}

// DeleteCustomFieldsWithBodyWithResponse request with arbitrary body returning *DeleteCustomFieldsResponse
func (c *ClientWithResponses) DeleteCustomFieldsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteCustomFieldsResponse, error) {
	rsp, err := c.DeleteCustomFieldsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCustomFieldsResponse(rsp)
}

func (c *ClientWithResponses) DeleteCustomFieldsWithResponse(ctx context.Context, body DeleteCustomFieldsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteCustomFieldsResponse, error) {
	rsp, err := c.DeleteCustomFields(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCustomFieldsResponse(rsp)
}

// ListCustomFieldKeysWithBodyWithResponse request with arbitrary body returning *ListCustomFieldKeysResponse
func (c *ClientWithResponses) ListCustomFieldKeysWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListCustomFieldKeysResponse, error) {
	rsp, err := c.ListCustomFieldKeysWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCustomFieldKeysResponse(rsp)
}

func (c *ClientWithResponses) ListCustomFieldKeysWithResponse(ctx context.Context, body ListCustomFieldKeysJSONRequestBody, reqEditors ...RequestEditorFn) (*ListCustomFieldKeysResponse, error) {
	rsp, err := c.ListCustomFieldKeys(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCustomFieldKeysResponse(rsp)
}

// DisableCustomFieldKeyWithBodyWithResponse request with arbitrary body returning *DisableCustomFieldKeyResponse
func (c *ClientWithResponses) DisableCustomFieldKeyWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DisableCustomFieldKeyResponse, error) {
	rsp, err := c.DisableCustomFieldKeyWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisableCustomFieldKeyResponse(rsp)
}

func (c *ClientWithResponses) DisableCustomFieldKeyWithResponse(ctx context.Context, body DisableCustomFieldKeyJSONRequestBody, reqEditors ...RequestEditorFn) (*DisableCustomFieldKeyResponse, error) {
	rsp, err := c.DisableCustomFieldKey(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisableCustomFieldKeyResponse(rsp)
}

// SetCustomFieldsWithBodyWithResponse request with arbitrary body returning *SetCustomFieldsResponse
func (c *ClientWithResponses) SetCustomFieldsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetCustomFieldsResponse, error) {
	rsp, err := c.SetCustomFieldsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetCustomFieldsResponse(rsp)
}

func (c *ClientWithResponses) SetCustomFieldsWithResponse(ctx context.Context, body SetCustomFieldsJSONRequestBody, reqEditors ...RequestEditorFn) (*SetCustomFieldsResponse, error) {
	rsp, err := c.SetCustomFields(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetCustomFieldsResponse(rsp)
}

// GetCustomerAlertWithBodyWithResponse request with arbitrary body returning *GetCustomerAlertResponse
func (c *ClientWithResponses) GetCustomerAlertWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetCustomerAlertResponse, error) {
	rsp, err := c.GetCustomerAlertWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomerAlertResponse(rsp)
}

func (c *ClientWithResponses) GetCustomerAlertWithResponse(ctx context.Context, body GetCustomerAlertJSONRequestBody, reqEditors ...RequestEditorFn) (*GetCustomerAlertResponse, error) {
	rsp, err := c.GetCustomerAlert(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomerAlertResponse(rsp)
}

// ListCustomerAlertsWithBodyWithResponse request with arbitrary body returning *ListCustomerAlertsResponse
func (c *ClientWithResponses) ListCustomerAlertsWithBodyWithResponse(ctx context.Context, params *ListCustomerAlertsParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ListCustomerAlertsResponse, error) {
	rsp, err := c.ListCustomerAlertsWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCustomerAlertsResponse(rsp)
}

func (c *ClientWithResponses) ListCustomerAlertsWithResponse(ctx context.Context, params *ListCustomerAlertsParams, body ListCustomerAlertsJSONRequestBody, reqEditors ...RequestEditorFn) (*ListCustomerAlertsResponse, error) {
	rsp, err := c.ListCustomerAlerts(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCustomerAlertsResponse(rsp)
}

// ListCustomersWithResponse request returning *ListCustomersResponse
func (c *ClientWithResponses) ListCustomersWithResponse(ctx context.Context, params *ListCustomersParams, reqEditors ...RequestEditorFn) (*ListCustomersResponse, error) {
	rsp, err := c.ListCustomers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCustomersResponse(rsp)
}

// CreateCustomerWithBodyWithResponse request with arbitrary body returning *CreateCustomerResponse
func (c *ClientWithResponses) CreateCustomerWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCustomerResponse, error) {
	rsp, err := c.CreateCustomerWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCustomerResponse(rsp)
}

func (c *ClientWithResponses) CreateCustomerWithResponse(ctx context.Context, body CreateCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCustomerResponse, error) {
	rsp, err := c.CreateCustomer(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCustomerResponse(rsp)
}

// GetCustomerWithResponse request returning *GetCustomerResponse
func (c *ClientWithResponses) GetCustomerWithResponse(ctx context.Context, customerId CustomerId, reqEditors ...RequestEditorFn) (*GetCustomerResponse, error) {
	rsp, err := c.GetCustomer(ctx, customerId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCustomerResponse(rsp)
}

// ListBillableMetricsWithResponse request returning *ListBillableMetricsResponse
func (c *ClientWithResponses) ListBillableMetricsWithResponse(ctx context.Context, customerId CustomerId, params *ListBillableMetricsParams, reqEditors ...RequestEditorFn) (*ListBillableMetricsResponse, error) {
	rsp, err := c.ListBillableMetrics(ctx, customerId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListBillableMetricsResponse(rsp)
}

// DeleteBillingConfigForCustomerWithResponse request returning *DeleteBillingConfigForCustomerResponse
func (c *ClientWithResponses) DeleteBillingConfigForCustomerWithResponse(ctx context.Context, customerId CustomerId, billingProviderTypeParam BillingProviderTypeParam, reqEditors ...RequestEditorFn) (*DeleteBillingConfigForCustomerResponse, error) {
	rsp, err := c.DeleteBillingConfigForCustomer(ctx, customerId, billingProviderTypeParam, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteBillingConfigForCustomerResponse(rsp)
}

// GetBillingConfigWithResponse request returning *GetBillingConfigResponse
func (c *ClientWithResponses) GetBillingConfigWithResponse(ctx context.Context, customerId CustomerId, billingProviderTypeParam BillingProviderTypeParam, reqEditors ...RequestEditorFn) (*GetBillingConfigResponse, error) {
	rsp, err := c.GetBillingConfig(ctx, customerId, billingProviderTypeParam, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBillingConfigResponse(rsp)
}

// SetBillingConfigForCustomerWithBodyWithResponse request with arbitrary body returning *SetBillingConfigForCustomerResponse
func (c *ClientWithResponses) SetBillingConfigForCustomerWithBodyWithResponse(ctx context.Context, customerId CustomerId, billingProviderTypeParam BillingProviderTypeParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetBillingConfigForCustomerResponse, error) {
	rsp, err := c.SetBillingConfigForCustomerWithBody(ctx, customerId, billingProviderTypeParam, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetBillingConfigForCustomerResponse(rsp)
}

func (c *ClientWithResponses) SetBillingConfigForCustomerWithResponse(ctx context.Context, customerId CustomerId, billingProviderTypeParam BillingProviderTypeParam, body SetBillingConfigForCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*SetBillingConfigForCustomerResponse, error) {
	rsp, err := c.SetBillingConfigForCustomer(ctx, customerId, billingProviderTypeParam, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetBillingConfigForCustomerResponse(rsp)
}

// GetCostsWithResponse request returning *GetCostsResponse
func (c *ClientWithResponses) GetCostsWithResponse(ctx context.Context, customerId CustomerId, params *GetCostsParams, reqEditors ...RequestEditorFn) (*GetCostsResponse, error) {
	rsp, err := c.GetCosts(ctx, customerId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCostsResponse(rsp)
}

// ListInvoicesWithResponse request returning *ListInvoicesResponse
func (c *ClientWithResponses) ListInvoicesWithResponse(ctx context.Context, customerId CustomerId, params *ListInvoicesParams, reqEditors ...RequestEditorFn) (*ListInvoicesResponse, error) {
	rsp, err := c.ListInvoices(ctx, customerId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListInvoicesResponse(rsp)
}

// ListInvoicesCachedWithResponse request returning *ListInvoicesCachedResponse
func (c *ClientWithResponses) ListInvoicesCachedWithResponse(ctx context.Context, customerId CustomerId, params *ListInvoicesCachedParams, reqEditors ...RequestEditorFn) (*ListInvoicesCachedResponse, error) {
	rsp, err := c.ListInvoicesCached(ctx, customerId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListInvoicesCachedResponse(rsp)
}

// GetInvoiceWithResponse request returning *GetInvoiceResponse
func (c *ClientWithResponses) GetInvoiceWithResponse(ctx context.Context, customerId CustomerId, invoiceId InvoiceId, reqEditors ...RequestEditorFn) (*GetInvoiceResponse, error) {
	rsp, err := c.GetInvoice(ctx, customerId, invoiceId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetInvoiceResponse(rsp)
}

// ListCustomerPlansWithResponse request returning *ListCustomerPlansResponse
func (c *ClientWithResponses) ListCustomerPlansWithResponse(ctx context.Context, customerId CustomerId, params *ListCustomerPlansParams, reqEditors ...RequestEditorFn) (*ListCustomerPlansResponse, error) {
	rsp, err := c.ListCustomerPlans(ctx, customerId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCustomerPlansResponse(rsp)
}

// AddPlanToCustomerWithBodyWithResponse request with arbitrary body returning *AddPlanToCustomerResponse
func (c *ClientWithResponses) AddPlanToCustomerWithBodyWithResponse(ctx context.Context, customerId CustomerId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddPlanToCustomerResponse, error) {
	rsp, err := c.AddPlanToCustomerWithBody(ctx, customerId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddPlanToCustomerResponse(rsp)
}

func (c *ClientWithResponses) AddPlanToCustomerWithResponse(ctx context.Context, customerId CustomerId, body AddPlanToCustomerJSONRequestBody, reqEditors ...RequestEditorFn) (*AddPlanToCustomerResponse, error) {
	rsp, err := c.AddPlanToCustomer(ctx, customerId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddPlanToCustomerResponse(rsp)
}

// EndCustomerPlanWithBodyWithResponse request with arbitrary body returning *EndCustomerPlanResponse
func (c *ClientWithResponses) EndCustomerPlanWithBodyWithResponse(ctx context.Context, customerId CustomerId, customerPlanId CustomerPlanId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EndCustomerPlanResponse, error) {
	rsp, err := c.EndCustomerPlanWithBody(ctx, customerId, customerPlanId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEndCustomerPlanResponse(rsp)
}

func (c *ClientWithResponses) EndCustomerPlanWithResponse(ctx context.Context, customerId CustomerId, customerPlanId CustomerPlanId, body EndCustomerPlanJSONRequestBody, reqEditors ...RequestEditorFn) (*EndCustomerPlanResponse, error) {
	rsp, err := c.EndCustomerPlan(ctx, customerId, customerPlanId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEndCustomerPlanResponse(rsp)
}

// GetPlanPriceAdjustmentsWithResponse request returning *GetPlanPriceAdjustmentsResponse
func (c *ClientWithResponses) GetPlanPriceAdjustmentsWithResponse(ctx context.Context, customerId CustomerId, customerPlanId CustomerPlanId, params *GetPlanPriceAdjustmentsParams, reqEditors ...RequestEditorFn) (*GetPlanPriceAdjustmentsResponse, error) {
	rsp, err := c.GetPlanPriceAdjustments(ctx, customerId, customerPlanId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlanPriceAdjustmentsResponse(rsp)
}

// SetIngestAliasesWithBodyWithResponse request with arbitrary body returning *SetIngestAliasesResponse
func (c *ClientWithResponses) SetIngestAliasesWithBodyWithResponse(ctx context.Context, customerId CustomerId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetIngestAliasesResponse, error) {
	rsp, err := c.SetIngestAliasesWithBody(ctx, customerId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetIngestAliasesResponse(rsp)
}

func (c *ClientWithResponses) SetIngestAliasesWithResponse(ctx context.Context, customerId CustomerId, body SetIngestAliasesJSONRequestBody, reqEditors ...RequestEditorFn) (*SetIngestAliasesResponse, error) {
	rsp, err := c.SetIngestAliases(ctx, customerId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetIngestAliasesResponse(rsp)
}

// SetCustomerNameWithBodyWithResponse request with arbitrary body returning *SetCustomerNameResponse
func (c *ClientWithResponses) SetCustomerNameWithBodyWithResponse(ctx context.Context, customerId CustomerId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetCustomerNameResponse, error) {
	rsp, err := c.SetCustomerNameWithBody(ctx, customerId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetCustomerNameResponse(rsp)
}

func (c *ClientWithResponses) SetCustomerNameWithResponse(ctx context.Context, customerId CustomerId, body SetCustomerNameJSONRequestBody, reqEditors ...RequestEditorFn) (*SetCustomerNameResponse, error) {
	rsp, err := c.SetCustomerName(ctx, customerId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetCustomerNameResponse(rsp)
}

// UpdateCustomerConfigWithBodyWithResponse request with arbitrary body returning *UpdateCustomerConfigResponse
func (c *ClientWithResponses) UpdateCustomerConfigWithBodyWithResponse(ctx context.Context, customerId CustomerId, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCustomerConfigResponse, error) {
	rsp, err := c.UpdateCustomerConfigWithBody(ctx, customerId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCustomerConfigResponse(rsp)
}

func (c *ClientWithResponses) UpdateCustomerConfigWithResponse(ctx context.Context, customerId CustomerId, body UpdateCustomerConfigJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCustomerConfigResponse, error) {
	rsp, err := c.UpdateCustomerConfig(ctx, customerId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCustomerConfigResponse(rsp)
}

// EmbeddableDashboardWithBodyWithResponse request with arbitrary body returning *EmbeddableDashboardResponse
func (c *ClientWithResponses) EmbeddableDashboardWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EmbeddableDashboardResponse, error) {
	rsp, err := c.EmbeddableDashboardWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEmbeddableDashboardResponse(rsp)
}

func (c *ClientWithResponses) EmbeddableDashboardWithResponse(ctx context.Context, body EmbeddableDashboardJSONRequestBody, reqEditors ...RequestEditorFn) (*EmbeddableDashboardResponse, error) {
	rsp, err := c.EmbeddableDashboard(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEmbeddableDashboardResponse(rsp)
}

// IngestWithBodyWithResponse request with arbitrary body returning *IngestResponse
func (c *ClientWithResponses) IngestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*IngestResponse, error) {
	rsp, err := c.IngestWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIngestResponse(rsp)
}

func (c *ClientWithResponses) IngestWithResponse(ctx context.Context, body IngestJSONRequestBody, reqEditors ...RequestEditorFn) (*IngestResponse, error) {
	rsp, err := c.Ingest(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIngestResponse(rsp)
}

// GetPlanDetailsWithResponse request returning *GetPlanDetailsResponse
func (c *ClientWithResponses) GetPlanDetailsWithResponse(ctx context.Context, planId PlanId, reqEditors ...RequestEditorFn) (*GetPlanDetailsResponse, error) {
	rsp, err := c.GetPlanDetails(ctx, planId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlanDetailsResponse(rsp)
}

// GetPlanChargesWithResponse request returning *GetPlanChargesResponse
func (c *ClientWithResponses) GetPlanChargesWithResponse(ctx context.Context, planId PlanId, params *GetPlanChargesParams, reqEditors ...RequestEditorFn) (*GetPlanChargesResponse, error) {
	rsp, err := c.GetPlanCharges(ctx, planId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlanChargesResponse(rsp)
}

// ListPlansWithResponse request returning *ListPlansResponse
func (c *ClientWithResponses) ListPlansWithResponse(ctx context.Context, params *ListPlansParams, reqEditors ...RequestEditorFn) (*ListPlansResponse, error) {
	rsp, err := c.ListPlans(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPlansResponse(rsp)
}

// GetUsageBatchWithBodyWithResponse request with arbitrary body returning *GetUsageBatchResponse
func (c *ClientWithResponses) GetUsageBatchWithBodyWithResponse(ctx context.Context, params *GetUsageBatchParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetUsageBatchResponse, error) {
	rsp, err := c.GetUsageBatchWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsageBatchResponse(rsp)
}

func (c *ClientWithResponses) GetUsageBatchWithResponse(ctx context.Context, params *GetUsageBatchParams, body GetUsageBatchJSONRequestBody, reqEditors ...RequestEditorFn) (*GetUsageBatchResponse, error) {
	rsp, err := c.GetUsageBatch(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsageBatchResponse(rsp)
}

// GetPagedUsageWithBodyWithResponse request with arbitrary body returning *GetPagedUsageResponse
func (c *ClientWithResponses) GetPagedUsageWithBodyWithResponse(ctx context.Context, params *GetPagedUsageParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*GetPagedUsageResponse, error) {
	rsp, err := c.GetPagedUsageWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPagedUsageResponse(rsp)
}

func (c *ClientWithResponses) GetPagedUsageWithResponse(ctx context.Context, params *GetPagedUsageParams, body GetPagedUsageJSONRequestBody, reqEditors ...RequestEditorFn) (*GetPagedUsageResponse, error) {
	rsp, err := c.GetPagedUsage(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPagedUsageResponse(rsp)
}

// ParseArchiveAlertResponse parses an HTTP response from a ArchiveAlertWithResponse call
func ParseArchiveAlertResponse(rsp *http.Response) (*ArchiveAlertResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ArchiveAlertResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data Id `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateAlertResponse parses an HTTP response from a CreateAlertWithResponse call
func ParseCreateAlertResponse(rsp *http.Response) (*CreateAlertResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAlertResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data Id `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListCreditTypesResponse parses an HTTP response from a ListCreditTypesWithResponse call
func ParseListCreditTypesResponse(rsp *http.Response) (*ListCreditTypesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCreditTypesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []struct {
				Id         *openapi_types.UUID `json:"id,omitempty"`
				IsCurrency *bool               `json:"is_currency,omitempty"`
				Name       *string             `json:"name,omitempty"`
			} `json:"data"`
			NextPage *string `json:"next_page"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateGrantResponse parses an HTTP response from a CreateGrantWithResponse call
func ParseCreateGrantResponse(rsp *http.Response) (*CreateGrantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateGrantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data Id `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListCreditLedgerEntriesResponse parses an HTTP response from a ListCreditLedgerEntriesWithResponse call
func ParseListCreditLedgerEntriesResponse(rsp *http.Response) (*ListCreditLedgerEntriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCreditLedgerEntriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data     []CustomerCreditTypeLedger `json:"data"`
			NextPage *string                    `json:"next_page"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListGrantsResponse parses an HTTP response from a ListGrantsWithResponse call
func ParseListGrantsResponse(rsp *http.Response) (*ListGrantsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListGrantsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data     []CreditGrant `json:"data"`
			NextPage *string       `json:"next_page"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseVoidGrantResponse parses an HTTP response from a VoidGrantWithResponse call
func ParseVoidGrantResponse(rsp *http.Response) (*VoidGrantResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VoidGrantResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data Id `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseAddCustomFieldKeyResponse parses an HTTP response from a AddCustomFieldKeyWithResponse call
func ParseAddCustomFieldKeyResponse(rsp *http.Response) (*AddCustomFieldKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddCustomFieldKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteCustomFieldsResponse parses an HTTP response from a DeleteCustomFieldsWithResponse call
func ParseDeleteCustomFieldsResponse(rsp *http.Response) (*DeleteCustomFieldsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCustomFieldsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseListCustomFieldKeysResponse parses an HTTP response from a ListCustomFieldKeysWithResponse call
func ParseListCustomFieldKeysResponse(rsp *http.Response) (*ListCustomFieldKeysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCustomFieldKeysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []struct {
				EnforceUniqueness bool          `json:"enforce_uniqueness"`
				Entity            ManagedEntity `json:"entity"`
				Key               string        `json:"key"`
			} `json:"data"`
			NextPage *string `json:"next_page"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDisableCustomFieldKeyResponse parses an HTTP response from a DisableCustomFieldKeyWithResponse call
func ParseDisableCustomFieldKeyResponse(rsp *http.Response) (*DisableCustomFieldKeyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DisableCustomFieldKeyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetCustomFieldsResponse parses an HTTP response from a SetCustomFieldsWithResponse call
func ParseSetCustomFieldsResponse(rsp *http.Response) (*SetCustomFieldsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetCustomFieldsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetCustomerAlertResponse parses an HTTP response from a GetCustomerAlertWithResponse call
func ParseGetCustomerAlertResponse(rsp *http.Response) (*GetCustomerAlertResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomerAlertResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data CustomerAlert `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListCustomerAlertsResponse parses an HTTP response from a ListCustomerAlertsWithResponse call
func ParseListCustomerAlertsResponse(rsp *http.Response) (*ListCustomerAlertsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCustomerAlertsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data     []CustomerAlert `json:"data"`
			NextPage *string         `json:"next_page"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListCustomersResponse parses an HTTP response from a ListCustomersWithResponse call
func ParseListCustomersResponse(rsp *http.Response) (*ListCustomersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCustomersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data     []CustomerDetail `json:"data"`
			NextPage *string          `json:"next_page"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateCustomerResponse parses an HTTP response from a CreateCustomerWithResponse call
func ParseCreateCustomerResponse(rsp *http.Response) (*CreateCustomerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCustomerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data Customer `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseGetCustomerResponse parses an HTTP response from a GetCustomerWithResponse call
func ParseGetCustomerResponse(rsp *http.Response) (*GetCustomerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCustomerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data CustomerDetail `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListBillableMetricsResponse parses an HTTP response from a ListBillableMetricsWithResponse call
func ParseListBillableMetricsResponse(rsp *http.Response) (*ListBillableMetricsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListBillableMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data     []BillableMetric `json:"data"`
			NextPage *string          `json:"next_page"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteBillingConfigForCustomerResponse parses an HTTP response from a DeleteBillingConfigForCustomerWithResponse call
func ParseDeleteBillingConfigForCustomerResponse(rsp *http.Response) (*DeleteBillingConfigForCustomerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteBillingConfigForCustomerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetBillingConfigResponse parses an HTTP response from a GetBillingConfigWithResponse call
func ParseGetBillingConfigResponse(rsp *http.Response) (*GetBillingConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBillingConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data struct {
				// AwsExpirationDate Contract expiration date for the customer. The expected format is RFC 3339 and can be retrieved from AWS's GetEntitlements API. (See https://docs.aws.amazon.com/marketplaceentitlement/latest/APIReference/API_GetEntitlements.html.)
				AwsExpirationDate         *AwsExpirationDate      `json:"aws_expiration_date,omitempty"`
				AwsProductCode            *string                 `json:"aws_product_code,omitempty"`
				AwsRegion                 *AwsRegion              `json:"aws_region,omitempty"`
				BillingProviderCustomerId *string                 `json:"billing_provider_customer_id,omitempty"`
				StripeCollectionMethod    *StripeCollectionMethod `json:"stripe_collection_method,omitempty"`
			} `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSetBillingConfigForCustomerResponse parses an HTTP response from a SetBillingConfigForCustomerWithResponse call
func ParseSetBillingConfigForCustomerResponse(rsp *http.Response) (*SetBillingConfigForCustomerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetBillingConfigForCustomerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetCostsResponse parses an HTTP response from a GetCostsWithResponse call
func ParseGetCostsResponse(rsp *http.Response) (*GetCostsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCostsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data     []Costs `json:"data"`
			NextPage *string `json:"next_page"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListInvoicesResponse parses an HTTP response from a ListInvoicesWithResponse call
func ParseListInvoicesResponse(rsp *http.Response) (*ListInvoicesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListInvoicesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data     []Invoice `json:"data"`
			NextPage *string   `json:"next_page"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListInvoicesCachedResponse parses an HTTP response from a ListInvoicesCachedWithResponse call
func ParseListInvoicesCachedResponse(rsp *http.Response) (*ListInvoicesCachedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListInvoicesCachedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data     []Invoice `json:"data"`
			NextPage *string   `json:"next_page"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetInvoiceResponse parses an HTTP response from a GetInvoiceWithResponse call
func ParseGetInvoiceResponse(rsp *http.Response) (*GetInvoiceResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetInvoiceResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data Invoice `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListCustomerPlansResponse parses an HTTP response from a ListCustomerPlansWithResponse call
func ParseListCustomerPlansResponse(rsp *http.Response) (*ListCustomerPlansResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCustomerPlansResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data     []CustomerPlan `json:"data"`
			NextPage *string        `json:"next_page"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddPlanToCustomerResponse parses an HTTP response from a AddPlanToCustomerWithResponse call
func ParseAddPlanToCustomerResponse(rsp *http.Response) (*AddPlanToCustomerResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddPlanToCustomerResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data Id `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseEndCustomerPlanResponse parses an HTTP response from a EndCustomerPlanWithResponse call
func ParseEndCustomerPlanResponse(rsp *http.Response) (*EndCustomerPlanResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EndCustomerPlanResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPlanPriceAdjustmentsResponse parses an HTTP response from a GetPlanPriceAdjustmentsWithResponse call
func ParseGetPlanPriceAdjustmentsResponse(rsp *http.Response) (*GetPlanPriceAdjustmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlanPriceAdjustmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data     []PriceAdjustment `json:"data"`
			NextPage *string           `json:"next_page"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetIngestAliasesResponse parses an HTTP response from a SetIngestAliasesWithResponse call
func ParseSetIngestAliasesResponse(rsp *http.Response) (*SetIngestAliasesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetIngestAliasesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSetCustomerNameResponse parses an HTTP response from a SetCustomerNameWithResponse call
func ParseSetCustomerNameResponse(rsp *http.Response) (*SetCustomerNameResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetCustomerNameResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data Customer `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseUpdateCustomerConfigResponse parses an HTTP response from a UpdateCustomerConfigWithResponse call
func ParseUpdateCustomerConfigResponse(rsp *http.Response) (*UpdateCustomerConfigResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCustomerConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseEmbeddableDashboardResponse parses an HTTP response from a EmbeddableDashboardWithResponse call
func ParseEmbeddableDashboardResponse(rsp *http.Response) (*EmbeddableDashboardResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EmbeddableDashboardResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data struct {
				Url *string `json:"url,omitempty"`
			} `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseIngestResponse parses an HTTP response from a IngestWithResponse call
func ParseIngestResponse(rsp *http.Response) (*IngestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IngestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetPlanDetailsResponse parses an HTTP response from a GetPlanDetailsWithResponse call
func ParseGetPlanDetailsResponse(rsp *http.Response) (*GetPlanDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlanDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data PlanDetail `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPlanChargesResponse parses an HTTP response from a GetPlanChargesWithResponse call
func ParseGetPlanChargesResponse(rsp *http.Response) (*GetPlanChargesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlanChargesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data     []PlanCharge `json:"data"`
			NextPage *string      `json:"next_page"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListPlansResponse parses an HTTP response from a ListPlansWithResponse call
func ParseListPlansResponse(rsp *http.Response) (*ListPlansResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPlansResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data     []Plan  `json:"data"`
			NextPage *string `json:"next_page"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUsageBatchResponse parses an HTTP response from a GetUsageBatchWithResponse call
func ParseGetUsageBatchResponse(rsp *http.Response) (*GetUsageBatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsageBatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data     []UsageBatchAggregate `json:"data"`
			NextPage *string               `json:"next_page"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetPagedUsageResponse parses an HTTP response from a GetPagedUsageWithResponse call
func ParseGetPagedUsageResponse(rsp *http.Response) (*GetPagedUsageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPagedUsageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data     []PagedUsageAggregate `json:"data"`
			NextPage *string               `json:"next_page"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"mcYmAQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
